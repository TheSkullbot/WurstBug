// this script was compiled with wurst 1.8.1.0-jenkins-Wurst-1244
globals
// real bj_GAME_STARTED_THRESHOLD=0.
// integer bj_MAX_PLAYERS=0
// integer bj_PLAYER_NEUTRAL_VICTIM=0
// integer bj_MAX_PLAYER_SLOTS=0
// integer bj_MAX_SKELETONS=0
// integer bj_MAX_STOCK_ITEM_SLOTS=0
// integer bj_MAX_STOCK_UNIT_SLOTS=0
// integer bj_MAX_ITEM_LEVEL=0
// real bj_TOD_DAWN=0.
// real bj_TOD_DUSK=0.
// real bj_MELEE_STARTING_TOD=0.
// integer bj_MELEE_STARTING_GOLD_V0=0
// integer bj_MELEE_STARTING_GOLD_V1=0
// integer bj_MELEE_STARTING_LUMBER_V0=0
// integer bj_MELEE_STARTING_LUMBER_V1=0
// integer bj_MELEE_HERO_LIMIT=0
// integer bj_MELEE_HERO_TYPE_LIMIT=0
// real bj_MELEE_CLEAR_UNITS_RADIUS=0.
// real bj_STOCK_RESTOCK_INITIAL_DELAY=0.
// real bj_STOCK_RESTOCK_INTERVAL=0.
// integer bj_STOCK_MAX_ITERATIONS=0
// real bj_RESCUE_PING_TIME=0.
// integer bj_MAX_QUEUED_TRIGGERS=0
// real bj_QUEUED_TRIGGER_TIMEOUT=0.
// real bj_CORPSE_MAX_DEATH_TIME=0.
// force bj_FORCE_ALL_PLAYERS=null
// rect bj_mapInitialPlayableArea=null
// boolean bj_slotControlReady=false
// timer bj_gameStartedTimer=null
// trigger bj_dncSoundsDay=null
// trigger bj_dncSoundsNight=null
// sound bj_dayAmbientSound=null
// sound bj_nightAmbientSound=null
// trigger bj_dncSoundsDawn=null
// trigger bj_dncSoundsDusk=null
// sound bj_dawnSound=null
// sound bj_duskSound=null
// boolean bj_useDawnDuskSounds=false
// boolean bj_dncIsDaytime=false
// sound bj_rescueSound=null
// trigger bj_stockItemPurchased=null
// timer bj_stockUpdateTimer=null
// integer bj_stockPickedItemLevel=0
// itemtype bj_stockPickedItemType=null
// trigger bj_rescueUnitBehavior=null
// boolean bj_rescueChangeColorUnit=false
// boolean bj_rescueChangeColorBldg=false
// integer bj_queuedExecTotal=0
// timer bj_queuedExecTimeoutTimer=null
// trigger bj_queuedExecTimeout=null
// integer bj_groupEnumTypeId=0
// player bj_groupEnumOwningPlayer=null
// location bj_enumDestructableCenter=null
// real bj_enumDestructableRadius=0.
// group bj_suspendDecayFleshGroup=null
// group bj_suspendDecayBoneGroup=null
// timer bj_delayedSuspendDecayTimer=null
// trigger bj_delayedSuspendDecayTrig=null
// integer bj_livingPlayerUnitsTypeId=0
// integer PLAYER_NEUTRAL_PASSIVE=0
// integer PLAYER_NEUTRAL_AGGRESSIVE=0
// alliancetype ALLIANCE_PASSIVE=null
// version VERSION_REIGN_OF_CHAOS=null
// racepreference RACE_PREF_HUMAN=null
// mapcontrol MAP_CONTROL_USER=null
// mapcontrol MAP_CONTROL_RESCUABLE=null
// gametype GAME_TYPE_MELEE=null
// gametype GAME_TYPE_FFA=null
// gametype GAME_TYPE_USE_MAP_SETTINGS=null
// gametype GAME_TYPE_ONE_ON_ONE=null
// gametype GAME_TYPE_TWO_TEAM_PLAY=null
// gametype GAME_TYPE_THREE_TEAM_PLAY=null
// gametype GAME_TYPE_FOUR_TEAM_PLAY=null
// placement MAP_PLACEMENT_USE_MAP_SETTINGS=null
// playerslotstate PLAYER_SLOT_STATE_PLAYING=null
// fgamestate GAME_STATE_TIME_OF_DAY=null
// playerstate PLAYER_STATE_RESOURCE_GOLD=null
// playerstate PLAYER_STATE_RESOURCE_LUMBER=null
// playerstate PLAYER_STATE_GIVES_BOUNTY=null
// unitstate UNIT_STATE_LIFE=null
// playerunitevent EVENT_PLAYER_UNIT_RESCUED=null
// playerunitevent EVENT_PLAYER_UNIT_SELL_ITEM=null
// limitop LESS_THAN=null
// limitop EQUAL=null
// limitop GREATER_THAN_OR_EQUAL=null
// unittype UNIT_TYPE_HERO=null
// unittype UNIT_TYPE_STRUCTURE=null
// itemtype ITEM_TYPE_PERMANENT=null
// itemtype ITEM_TYPE_CHARGED=null
// itemtype ITEM_TYPE_ARTIFACT=null
// integer CAMERA_MARGIN_LEFT=0
// integer CAMERA_MARGIN_RIGHT=0
// integer CAMERA_MARGIN_TOP=0
// integer CAMERA_MARGIN_BOTTOM=0
// originframetype ORIGIN_FRAME_GAME_UI=null
trigger gg_trg_Melee_Initialization=null
real Angle_DEGTORAD=0.
real Angle_RADTODEG=0.
real Basics_ANIMATION_PERIOD=0.
integer Basics_HEIGHT_ENABLER=0
player Basics_DUMMY_PLAYER=null
integer BitSet_BITSET_SIZE=0
integer array BitSet_pows
integer array ClosureForGroups_tempCallbacks
integer ClosureForGroups_tempCallbacksCount=0
integer ClosureForGroups_maxCount=0
integer ClosureForGroups_iterCount=0
integer ClosureTimers_x=0
integer Colors_COLOR_WHITE_red=0
integer Colors_COLOR_WHITE_green=0
integer Colors_COLOR_WHITE_blue=0
integer Colors_COLOR_WHITE_alpha=0
integer array Colors_PLAYER_COLORS_red
integer array Colors_PLAYER_COLORS_green
integer array Colors_PLAYER_COLORS_blue
string array Colors_hexs
integer Colors_decs=0
integer DummyRecycler_DUMMY_UNIT_ID=0
integer DummyRecycler_ROOT_ENABLER=0
integer DummyRecycler_DIFFERENT_ANGLES=0
real DummyRecycler_ANGLE_DEGREE=0.
integer DummyRecycler_SAVED_UNITS_PER_ANGLE=0
timer DelayNode_t=null
integer DelayNode_first=0
integer array DummyRecycler_angleQueues
integer ErrorHandling_MUTE_ERROR_DURATION=0
integer ErrorHandling_PRIMARY_ERROR_KEY=0
hashtable ErrorHandling_HT=null
boolean ErrorHandling_suppressErrorMessages=false
framehandle Framehandle_GAME_UI=null
timer GameTimer_gameTimer=null
real GameTimer_currentTime=0.
hashtable HashList_ht=null
hashtable HashList_occurences=null
integer Integer_INT_MAX=0
integer LocalObjectIDs_UNIT_FOUNDER=0
boolean MagicFunctions_compiletime=false
rect MapBounds_playableMapRect=null
rect MapBounds_boundRect=null
real MapBounds_playableMin_x=0.
real MapBounds_playableMin_y=0.
real MapBounds_playableMax_x=0.
real MapBounds_playableMax_y=0.
real MapBounds_boundMin_x=0.
real MapBounds_boundMin_y=0.
real MapBounds_boundMax_x=0.
real MapBounds_boundMax_y=0.
real Matrices_ZERO44_m00=0.
real Matrices_ZERO44_m01=0.
real Matrices_ZERO44_m02=0.
real Matrices_ZERO44_m03=0.
real Matrices_ZERO44_m10=0.
real Matrices_ZERO44_m11=0.
real Matrices_ZERO44_m12=0.
real Matrices_ZERO44_m13=0.
real Matrices_ZERO44_m20=0.
real Matrices_ZERO44_m21=0.
real Matrices_ZERO44_m22=0.
real Matrices_ZERO44_m23=0.
real Matrices_ZERO44_m30=0.
real Matrices_ZERO44_m31=0.
real Matrices_ZERO44_m32=0.
real Matrices_ZERO44_m33=0.
integer ObjectIDManager_DEST_ID_GEN=0
integer ObjectIDManager_shortcuts=0
integer ObjectIDManager_values=0
integer ObjectIDManager_types=0
integer ObjectIDManager_names=0
integer ObjectIdGenerator_UNIT_ID_GEN=0
integer ObjectIdGenerator_HERO_ID_GEN=0
integer ObjectIdGenerator_ABIL_ID_GEN=0
integer ObjectIdGenerator_BUFF_ID_GEN=0
integer ObjectIdGenerator_ITEM_ID_GEN=0
integer ObjectIdGenerator_UPGD_ID_GEN=0
player array Player_players
player Player_localPlayer=null
boolean Preloader_autoFinish=false
group Preloader_dumg=null
unit Preloader_dum=null
integer Printing_DEBUG_LEVEL=0
real Printing_DEBUG_MSG_DURATION=0.
real Real_REAL_MAX=0.
string String_charset=null
string String_numberset=null
hashtable Table_ht=null
timer array TimerUtils_freeTimers
integer TimerUtils_freeTimersCount=0
integer TimerUtils_timerData=0
integer TimerUtils_HELD=0
integer TypeCasting_typecastdata=0
real TypeCasting_R2I_PRECISION=0.
real Vectors_ZERO2_x=0.
real Vectors_ZERO2_y=0.
hashtable hashtable_compiletime=null
hashtable hashtable_compiletime_245=null
hashtable hashtable_compiletime_246=null
hashtable hashtable_compiletime_247=null
integer array ForGroupCallback_nextFree
integer ForGroupCallback_firstFree=0
integer ForGroupCallback_maxIndex=0
integer array ForGroupCallback_typeId
integer array CallbackSingle_nextFree
integer CallbackSingle_firstFree=0
integer CallbackSingle_maxIndex=0
integer array CallbackSingle_typeId
integer array ArrayQueue_nextFree
integer ArrayQueue_firstFree=0
integer ArrayQueue_maxIndex=0
integer array ArrayQueue_typeId
integer DelayNode_firstFree=0
integer array DelayNode_typeId
integer array HashList_typeId
integer array Table_nextFree
integer Table_firstFree=0
integer Table_maxIndex=0
integer array Table_typeId
integer array Comparator_nextFree
integer Comparator_firstFree=0
integer Comparator_maxIndex=0
integer array LLEntry_nextFree
integer LLEntry_firstFree=0
integer LLEntry_maxIndex=0
integer array LinkedList_typeId
integer array IdGenerator_nextFree
integer IdGenerator_firstFree=0
integer IdGenerator_maxIndex=0
timer array CallbackSingle_t
integer array ArrayQueue_rp
integer array ArrayQueue_size
unit array DelayNode_u
real array DelayNode_delayTime
integer array DelayNode_next
integer array HashList_size
integer array HashMap_size
integer array IterableMap_keys
integer array result
integer array LLEntry_prev
integer array LinkedList_dummy
integer array LinkedList_size
integer wurst_stack_depth=0
string array wurst_stack
real real_asAngleDegrees_return_radians=0.
real vec2_op_minus_return_x=0.
real vec2_op_minus_return_y=0.
real player_getStartLocation_return_x=0.
real player_getStartLocation_return_y=0.
real vec2_op_plus_return_x=0.
real vec2_op_plus_return_y=0.
real vec2_op_mult_return_x=0.
real vec2_op_mult_return_y=0.
code ref_function_Trig_Melee_Initialization_Actions=null
code ref_function_init_Abilities=null
code ref_function_init_AbilityIds=null
code ref_function_init_Real=null
code ref_function_init_Integer=null
code ref_function_init_BitSet=null
code ref_function_init_String=null
code ref_function_init_TargetsAllowed=null
code ref_function_init_Angle=null
code ref_function_init_Vectors=null
code ref_function_init_Player=null
code ref_function_init_Destructable=null
code ref_function_init_Maths=null
code ref_function_init_Printing=null
code ref_function_init_MagicFunctions=null
code ref_function_init_Basics=null
code ref_function_init_GameTimer=null
code ref_function_init_ErrorHandling=null
code ref_function_init_Matrices=null
code ref_function_init_Quaternion=null
code ref_function_init_Table=null
code ref_function_init_Playercolor=null
code ref_function_bridge_init_Colors=null
code ref_function_init_Framehandle=null
code ref_function_init_Group=null
code ref_function_init_Lightning=null
code ref_function_init_WeatherEffects=null
code ref_function_bridge_init_TypeCasting=null
code ref_function_init_HashList=null
code ref_function_bridge_init_EventHelper=null
code ref_function_init_AbilityObjEditing=null
code ref_function_init_AttachmentPoints=null
code ref_function_init_Buildings=null
code ref_function_init_ClosureForGroups=null
code ref_function_bridge_init_TimerUtils=null
code ref_function_init_ClosureTimers=null
code ref_function_init_Doodads=null
code ref_function_init_MapBounds=null
code ref_function_bridge_init_LinkedList=null
code ref_function_init_ObjectIds=null
code ref_function_init_UnitIds=null
code ref_function_init_Icons=null
code ref_function_bridge_init_DummyRecycler=null
code ref_function_init_Objects=null
code ref_function_init_Sounds=null
code ref_function_init_Soundsets=null
code ref_function_init_Textures=null
code ref_function_init_UI=null
code ref_function_init_Units=null
code ref_function_bridge_init_Preloader=null
code ref_function_bridge_init_ObjectIdGenerator=null
code ref_function_bridge_init_ObjectIDManager=null
code ref_function_bridge_init_LocalObjectIDs=null
code ref_function_init_Founder=null
code ref_function_bridge_code__Filter_ClosureForGroups=null
code ref_function_bridge_DelayNode_recycle=null
code ref_function_code__startPeriodic_GameTimer=null
code ref_function_bridge_code__start_CallbackSingle_ClosureTimers=null
unit createDummytempReturn=null
unit group_nexttempReturn=null
timer getTimertempReturn=null
endglobals
function InitGlobals takes nothing returns nothing
endfunction

function InitTrig_Melee_Initialization takes nothing returns nothing
	set gg_trg_Melee_Initialization = CreateTrigger()
	call TriggerAddAction(gg_trg_Melee_Initialization, ref_function_Trig_Melee_Initialization_Actions)
endfunction

function Loglevel_getTag takes integer this returns string
	local integer temp = this
	if temp == 0 then
		return "|cffADADADtrace|r"
	elseif temp == 1 then
		return "|cff2685DCdebug|r"
	elseif temp == 2 then
		return "|cffFFCC00info|r"
	elseif temp == 3 then
		return "|cffF47E3Ewarning|r"
	else
		return "|cffFB2700error|r"
	endif
endfunction

function printLog takes player showTo, integer loglvl, string msg returns nothing
	local string compositeMsg
	if Printing_DEBUG_LEVEL <= loglvl then
		set compositeMsg = Loglevel_getTag(loglvl) + " - " + msg
		call DisplayTimedTextToPlayer(showTo, 0., 0., Printing_DEBUG_MSG_DURATION, compositeMsg)
	endif
endfunction

function Log_error takes string msg returns nothing
	call printLog(Player_localPlayer, 4, msg)
endfunction

function compileError takes string msg returns nothing
endfunction

function hashtable_hasBoolean takes hashtable this, integer parentKey, integer childKey returns boolean
	return HaveSavedBoolean(this, parentKey, childKey)
endfunction

function hashtable_hasInt takes hashtable this, integer parentKey, integer childKey returns boolean
	return HaveSavedInteger(this, parentKey, childKey)
endfunction

function hashtable_loadBoolean takes hashtable this, integer parentKey, integer childKey returns boolean
	return LoadBoolean(this, parentKey, childKey)
endfunction

function hashtable_loadInt takes hashtable this, integer parentKey, integer childKey returns integer
	return LoadInteger(this, parentKey, childKey)
endfunction

function hashtable_saveBoolean takes hashtable this, integer parentKey, integer childKey, boolean value returns nothing
	call SaveBoolean(this, parentKey, childKey, value)
endfunction

function hashtable_saveInt takes hashtable this, integer parentKey, integer childKey, integer value returns nothing
	call SaveInteger(this, parentKey, childKey, value)
endfunction

function real_toInt takes real this returns integer
	return R2I(this)
endfunction

function string_getHash takes string this returns integer
	return StringHash(this)
endfunction

function error takes string msg, string w__wurst_stackPos returns nothing
	local integer hash
	local string stacktraceStr
	local integer stacktraceIndex
	local integer stacktraceLimit
	local string stacktraceStr_1
	local integer stacktraceIndex_1
	local integer stacktraceLimit_1
	local string temp
	local string temp_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if MagicFunctions_compiletime then
		call compileError("ERROR: " + msg)
	else
		if  not ErrorHandling_suppressErrorMessages then
			set hash = string_getHash(msg)
			if hashtable_hasInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
				if hashtable_loadInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) + ErrorHandling_MUTE_ERROR_DURATION < GameTimer_currentTime then
					set temp = msg
					set stacktraceStr = ""
					set stacktraceIndex = wurst_stack_depth
					set stacktraceLimit = 0
					loop
						set stacktraceIndex = stacktraceIndex - 1
						set stacktraceLimit = stacktraceLimit + 1
						exitwhen stacktraceLimit > 20
						exitwhen stacktraceIndex < 0
						set stacktraceStr = stacktraceStr + "\n   " + wurst_stack[stacktraceIndex]
					endloop
					call Log_error(temp + stacktraceStr)
					call hashtable_saveInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, real_toInt(GameTimer_currentTime))
					call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, false)
				elseif hashtable_hasBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
					if  not hashtable_loadBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash) then
						call Log_error("|cffFF3A29Excessive repeating errors are being omitted")
						call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, true)
					endif
				else
					call Log_error("|cffFF3A29Excessive repeating errors are being omitted")
					call hashtable_saveBoolean(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, true)
				endif
			else
				call hashtable_saveInt(ErrorHandling_HT, ErrorHandling_PRIMARY_ERROR_KEY, hash, real_toInt(GameTimer_currentTime))
				set temp_1 = "Message: " + msg
				set stacktraceStr_1 = ""
				set stacktraceIndex_1 = wurst_stack_depth
				set stacktraceLimit_1 = 0
				loop
					set stacktraceIndex_1 = stacktraceIndex_1 - 1
					set stacktraceLimit_1 = stacktraceLimit_1 + 1
					exitwhen stacktraceLimit_1 > 20
					exitwhen stacktraceIndex_1 < 0
					set stacktraceStr_1 = stacktraceStr_1 + "\n   " + wurst_stack[stacktraceIndex_1]
				endloop
				call Log_error(temp_1 + stacktraceStr_1)
			endif
		endif
		call I2S(1 / 0)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function initCompiletimeState_0 takes nothing returns nothing
	set hashtable_compiletime_247 = InitHashtable()
	set hashtable_compiletime_246 = InitHashtable()
	set hashtable_compiletime_245 = InitHashtable()
	set hashtable_compiletime = InitHashtable()
	call SaveInteger(hashtable_compiletime_247, 1, -1663695754, 13)
	call SaveStr(hashtable_compiletime_247, 2, 1804483594, "air")
	call SaveInteger(hashtable_compiletime_247, 38, 18021568, 0)
	call SaveStr(hashtable_compiletime_247, 2, -543400682, "vulnerable")
	call SaveInteger(hashtable_compiletime_247, 1, 789744696, 15)
	call SaveStr(hashtable_compiletime_247, 2, 124309475, "structure")
	call SaveStr(hashtable_compiletime_247, 2, -1636865566, "BUFF_")
	call SaveInteger(hashtable_compiletime_247, 1, -1894922563, 8)
	call SaveInteger(hashtable_compiletime_247, 1, -680649701, 4)
	call SaveStr(hashtable_compiletime_247, 2, 1916262177, "xdaa")
	call SaveStr(hashtable_compiletime_247, 2, -1989411722, "UNIT_BUILDING_TENT")
	call SaveInteger(hashtable_compiletime_247, 39, -391106256, 2016423987)
	call SaveStr(hashtable_compiletime_247, 2, -1221441622, "debris")
	call SaveInteger(hashtable_compiletime_247, 1, -242600650, 0)
	call SaveInteger(hashtable_compiletime_247, 1, -647782241, 2)
	call SaveStr(hashtable_compiletime_247, 2, 2061619198, "UPGD_")
	call SaveInteger(hashtable_compiletime_247, 38, -2146117459, 6)
	call SaveInteger(hashtable_compiletime_247, 39, -1989411722, 2016423985)
	call SaveStr(hashtable_compiletime_247, 2, -391106256, "UNIT_BUILDING_LAMP")
	call SaveStr(hashtable_compiletime_247, 2, -85648186, "ward")
	call SaveInteger(hashtable_compiletime_247, 41, 1213018161, 1098885161)
	call SaveStr(hashtable_compiletime_247, 2, 18021568, "UNIT_")
	call SaveStr(hashtable_compiletime_247, 2, -1912775212, "invulnerable")
	call SaveInteger(hashtable_compiletime_247, 1, -1676716706, 11)
	call SaveInteger(hashtable_compiletime_247, 38, 1559216385, 4)
	call SaveInteger(hashtable_compiletime_247, 39, 1632931561, 2016423986)
	call SaveInteger(hashtable_compiletime_247, 38, 2061619198, 5)
	call SaveStr(hashtable_compiletime_247, 2, -2146117459, "DEST_")
	call SaveStr(hashtable_compiletime_247, 2, 1632931561, "UNIT_BUILDING_CAMPFIRE")
	call SaveStr(hashtable_compiletime_247, 2, -331400573, "ABIL_")
	call SaveInteger(hashtable_compiletime_247, 40, 1098885161, 0)
	call SaveInteger(hashtable_compiletime_247, 1, -854572045, 3)
	call SaveInteger(hashtable_compiletime_247, 1, 349230650, 7)
	call SaveInteger(hashtable_compiletime_247, 1, -1559655710, 12)
	call SaveInteger(hashtable_compiletime_247, 1, -1587459251, 10)
	call SaveInteger(hashtable_compiletime_247, 1, 597637742, 14)
	call SaveInteger(hashtable_compiletime_247, 38, -1636865566, 3)
	call SaveInteger(hashtable_compiletime_247, 38, 58807802, 1)
	call SaveInteger(hashtable_compiletime_247, 40, 1632931561, 0)
	call SaveStr(hashtable_compiletime_247, 2, 1098885161, "UNIT_FOUNDER")
	call SaveStr(hashtable_compiletime_247, 2, 392811314, "item")
	call SaveInteger(hashtable_compiletime_247, 41, 2016423985, -1989411722)
	call SaveInteger(hashtable_compiletime_247, 41, 2016423986, 1632931561)
	call SaveInteger(hashtable_compiletime_247, 41, 2016423987, -391106256)
	call SaveInteger(hashtable_compiletime_247, 39, 1098885161, 1213018161)
	call SaveStr(hashtable_compiletime_247, 2, -539662199, "x003")
	call SaveInteger(hashtable_compiletime_247, 1, 1132341824, 1)
	call SaveInteger(hashtable_compiletime_247, 38, -331400573, 2)
	call SaveStr(hashtable_compiletime_247, 2, -681966791, "ground")
	call SaveStr(hashtable_compiletime_247, 2, 1282521876, "Aloc")
	call SaveInteger(hashtable_compiletime_247, 40, -1989411722, 0)
	call SaveInteger(hashtable_compiletime_247, 1, -1474492777, 9)
	call SaveStr(hashtable_compiletime_247, 2, 1706787410, "x002")
	call SaveInteger(hashtable_compiletime_247, 1, -943650483, 5)
	call SaveStr(hashtable_compiletime_247, 2, 1559216385, "ITEM_")
	call SaveStr(hashtable_compiletime_247, 2, 1379825362, "Ahrp")
	call SaveStr(hashtable_compiletime_247, 2, 1144624970, "x001")
	call SaveStr(hashtable_compiletime_247, 2, -612826229, "Avul")
	call SaveInteger(hashtable_compiletime_247, 1, -671760605, 6)
	call SaveStr(hashtable_compiletime_247, 2, 58807802, "HERO_")
	call SaveInteger(hashtable_compiletime_247, 40, -391106256, 0)
	call SaveStr(hashtable_compiletime_247, 2, 0, "")
endfunction

function initCompiletimeState takes nothing returns nothing
	call ExecuteFunc("initCompiletimeState_0")
endfunction

function Trig_Melee_Initialization_Actions takes nothing returns nothing
	call MeleeStartingVisibility()
	call MeleeStartingHeroLimit()
	call MeleeStartingResources()
	call MeleeClearExcessUnits()
endfunction

function ArrayQueue_units_set takes integer instanceId, integer arrayIndex, unit value, string stackPos returns nothing
	if arrayIndex < 0 or arrayIndex >= 6 then
		call error("Index out of Bounds", stackPos)
	elseif arrayIndex <= 2 then
		if arrayIndex <= 1 then
			if arrayIndex <= 0 then
			endif
		endif
	elseif arrayIndex <= 4 then
		if arrayIndex <= 3 then
		endif
	endif
endfunction

function ArrayQueue_enqueue takes integer this, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ArrayQueue_size[this] < DummyRecycler_SAVED_UNITS_PER_ANGLE then
		set ArrayQueue_size[this] = ArrayQueue_size[this] + 1
		set ArrayQueue_rp[this] = ModuloInteger(ArrayQueue_rp[this] + 1, DummyRecycler_SAVED_UNITS_PER_ANGLE)
		call ArrayQueue_units_set(this, ArrayQueue_rp[this], u, "when writing array ArrayQueue_units in DummyRecycler, line 70")
	else
		call error("Queue Overflow", "when calling error in DummyRecycler, line 72")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_ArrayQueue_DummyRecycler_ArrayQueue_enqueue takes integer this, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ArrayQueue_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling ArrayQueue.enqueue", "when calling error in DummyRecycler, line 66")
		else
			call error("Called ArrayQueue.enqueue on invalid object.", "when calling error in DummyRecycler, line 66")
		endif
	endif
	call ArrayQueue_enqueue(this, u, "when calling enqueue in DummyRecycler, line 66")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function real_asAngleDegrees takes real this returns real
	set real_asAngleDegrees_return_radians = this * Angle_DEGTORAD
	return real_asAngleDegrees_return_radians
endfunction

function unit_pause takes unit this returns nothing
	call PauseUnit(this, true)
endfunction

function unit_remove takes unit this returns nothing
	call RemoveUnit(this)
endfunction

function angle_degrees takes real this_radians returns real
	return this_radians * Angle_RADTODEG
endfunction

function unit_setFacing takes unit this, real a_radians returns nothing
	call SetUnitFacing(this, angle_degrees(a_radians))
endfunction

function unit_setScale takes unit this, real scale returns nothing
	call SetUnitScale(this, scale, scale, scale)
endfunction

function unit_setVertexColor takes unit this, integer col_red, integer col_green, integer col_blue, integer col_alpha returns nothing
	call SetUnitVertexColor(this, col_red, col_green, col_blue, col_alpha)
endfunction

function unit_setX takes unit this, real x returns nothing
	call SetUnitX(this, x)
endfunction

function unit_setY takes unit this, real y returns nothing
	call SetUnitY(this, y)
endfunction

function unit_setXY takes unit this, real pos_x, real pos_y returns nothing
	local unit receiver = this
	local unit receiver_1
	call unit_setX(receiver, pos_x)
	set receiver_1 = receiver
	call unit_setY(receiver_1, pos_y)
	set receiver = null
	set receiver_1 = null
endfunction

function vec2_op_minus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_minus_return_x = this_x - v_x
	set vec2_op_minus_return_y = this_y - v_y
	return vec2_op_minus_return_x
endfunction

function DummyRecycler_recycle takes unit u, string w__wurst_stackPos returns nothing
	local integer smallestQueue
	local integer i
	local integer temp
	local unit receiver
	local unit receiver_1
	local unit receiver_2
	local unit receiver_3
	local unit receiver_4
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set smallestQueue = 0
	set i = 1
	set temp = DummyRecycler_DIFFERENT_ANGLES - 1
	loop
		exitwhen i > temp
		if ArrayQueue_size[DummyRecycler_angleQueues[smallestQueue]] > ArrayQueue_size[DummyRecycler_angleQueues[i]] then
			set smallestQueue = i
		endif
		set i = i + 1
	endloop
	if ArrayQueue_size[DummyRecycler_angleQueues[smallestQueue]] >= DummyRecycler_SAVED_UNITS_PER_ANGLE then
		call unit_remove(u)
	else
		call dispatch_ArrayQueue_DummyRecycler_ArrayQueue_enqueue(DummyRecycler_angleQueues[smallestQueue], u, "when calling enqueue in DummyRecycler, line 51")
		set receiver = u
		call unit_setXY(receiver, vec2_op_minus(MapBounds_boundMax_x, MapBounds_boundMax_y, 16., 16.), vec2_op_minus_return_y)
		set receiver_1 = receiver
		call unit_pause(receiver_1)
		set receiver_2 = receiver_1
		call unit_setFacing(receiver_2, real_asAngleDegrees(smallestQueue * DummyRecycler_ANGLE_DEGREE))
		set receiver_3 = receiver_2
		call unit_setScale(receiver_3, 1.)
		set receiver_4 = receiver_3
		call unit_setVertexColor(receiver_4, Colors_COLOR_WHITE_red, Colors_COLOR_WHITE_green, Colors_COLOR_WHITE_blue, Colors_COLOR_WHITE_alpha)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
	set receiver_3 = null
	set receiver_4 = null
endfunction

function DelayNode_onDestroy takes integer this returns nothing
endfunction

function dealloc_DelayNode takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if DelayNode_typeId[obj] == 0 then
		call error("Double free: object of type DelayNode", "when calling error in DummyRecycler, line 83")
	else
		set DelayNode_firstFree = DelayNode_firstFree + 1
		set DelayNode_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyDelayNode takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call DelayNode_onDestroy(this)
	call dealloc_DelayNode(this, "when calling dealloc_DelayNode in DummyRecycler, line 83")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_DelayNode_destroyDelayNode takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if DelayNode_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling DelayNode.DelayNode", "when calling error in DummyRecycler, line 83")
		else
			call error("Called DelayNode.DelayNode on invalid object.", "when calling error in DummyRecycler, line 83")
		endif
	endif
	call destroyDelayNode(this, "when calling destroyDelayNode in DummyRecycler, line 83")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_getElapsed takes timer this returns real
	return TimerGetElapsed(this)
endfunction

function getElapsedGameTime takes nothing returns real
	return timer_getElapsed(GameTimer_gameTimer)
endfunction

function timer_start takes timer this, real time, code timerCallBack returns nothing
	call TimerStart(this, time, false, timerCallBack)
endfunction

function DelayNode_recycle takes string w__wurst_stackPos returns nothing
	local integer tmp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call DummyRecycler_recycle(DelayNode_u[DelayNode_first], "when calling recycle in DummyRecycler, line 132")
	set tmp = DelayNode_first
	if DelayNode_next[DelayNode_first] == 0 then
		set DelayNode_first = 0
	else
		set DelayNode_first = DelayNode_next[DelayNode_first]
		call timer_start(DelayNode_t, DelayNode_delayTime[DelayNode_first] - getElapsedGameTime(), ref_function_bridge_DelayNode_recycle)
	endif
	call dispatch_DelayNode_destroyDelayNode(tmp, "when calling dispatch_DelayNode_destroyDelayNode in DummyRecycler, line 141")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_DelayNode_recycle takes nothing returns nothing
	set wurst_stack_depth = 0
	call DelayNode_recycle("via function reference DummyRecycler, line 139")
endfunction

function currentCallback takes nothing returns integer
	return ClosureForGroups_tempCallbacks[ClosureForGroups_tempCallbacksCount - 1]
endfunction

function alloc_LLEntry takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LLEntry_firstFree == 0 then
		if LLEntry_maxIndex < 32768 then
			set LLEntry_maxIndex = LLEntry_maxIndex + 1
			set this = LLEntry_maxIndex
		else
			call error("Out of memory: Could not create LLEntry.", "when calling error in LinkedList, line 415")
			set this = 0
		endif
	else
		set LLEntry_firstFree = LLEntry_firstFree - 1
		set this = LLEntry_nextFree[LLEntry_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function LLEntry_init takes integer this returns nothing
endfunction

function construct_LLEntry takes integer this, integer elem, integer prev, integer next returns nothing
	call LLEntry_init(this)
	set LLEntry_prev[this] = prev
endfunction

function new_LLEntry takes integer elem, integer prev, integer next, string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this = alloc_LLEntry("when calling alloc_LLEntry in LinkedList, line 420")
	call construct_LLEntry(this, elem, prev, next)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function LinkedList_add_1 takes integer this, integer elems_0, string w__wurst_stackPos returns nothing
	local integer entry
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set entry = new_LLEntry(elems_0, LLEntry_prev[LinkedList_dummy[this]], LinkedList_dummy[this], "when calling new_LLEntry in LinkedList, line 40")
	set LLEntry_prev[LinkedList_dummy[this]] = entry
	set LinkedList_size[this] = LinkedList_size[this] + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_LinkedList_LinkedList_LinkedList_add_1 takes integer this, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if LinkedList_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling LinkedList.add", "when calling error in LinkedList, line 38")
		else
			call error("Called LinkedList.add on invalid object.", "when calling error in LinkedList, line 38")
		endif
	endif
	call LinkedList_add_1(this, elems_0, "when calling add in LinkedList, line 38")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function handle_getHandleId takes handle this returns integer
	return GetHandleId(this)
endfunction

function unitToIndex takes unit object returns integer
	return handle_getHandleId(object)
endfunction

function callback_forEachFrom_LinkedList takes integer this, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_LinkedList_LinkedList_LinkedList_add_1(result[this], unitToIndex(u), "when calling add in LinkedList, line 544")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function callback_forEachFrom_Preloader takes integer this, unit u returns nothing
	call unit_remove(u)
endfunction

function dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback takes integer this, unit u, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling ForGroupCallback.callback", "when calling error in ClosureForGroups, line 4")
		else
			call error("Called ForGroupCallback.callback on invalid object.", "when calling error in ClosureForGroups, line 4")
		endif
	endif
	if ForGroupCallback_typeId[this] <= 651 then
		call callback_forEachFrom_LinkedList(this, u, "when calling callback_forEachFrom_LinkedList in ClosureForGroups, line 4")
	else
		call callback_forEachFrom_Preloader(this, u)
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function filterCallback takes unit filter, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ClosureForGroups_iterCount < ClosureForGroups_maxCount then
		call dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback(currentCallback(), filter, "when calling callback in ClosureForGroups, line 18")
	endif
	set ClosureForGroups_iterCount = ClosureForGroups_iterCount + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function code__Filter_ClosureForGroups takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call filterCallback(GetFilterUnit(), "when calling filterCallback in ClosureForGroups, line 14")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__Filter_ClosureForGroups takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__Filter_ClosureForGroups("via function reference ClosureForGroups, line 14")
endfunction

function call_doAfter_ClosureTimers takes integer this returns nothing
	set ClosureTimers_x = ClosureTimers_x + 50
endfunction

function call_doAfter_ClosureTimers_278 takes integer this returns nothing
	set ClosureTimers_x = ClosureTimers_x * 2
endfunction

function int_toString takes integer this returns string
	return I2S(this)
endfunction

function testFail takes string msg returns nothing
endfunction

function int_assertEquals takes integer this, integer expected returns nothing
	if this != expected then
		call testFail("Expected <" + int_toString(expected) + ">, Actual <" + int_toString(this) + ">")
	endif
endfunction

function call_doAfter_ClosureTimers_279 takes integer this returns nothing
	set ClosureTimers_x = ClosureTimers_x / 2
	call int_assertEquals(ClosureTimers_x, 250)
endfunction

function alloc_ForGroupCallback_forEachFrom_Preloader takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_firstFree == 0 then
		if ForGroupCallback_maxIndex < 32768 then
			set ForGroupCallback_maxIndex = ForGroupCallback_maxIndex + 1
			set this = ForGroupCallback_maxIndex
			set ForGroupCallback_typeId[this] = 652
		else
			call error("Out of memory: Could not create ForGroupCallback_forEachFrom_Preloader.", "when calling error in Preloader, line 46")
			set this = 0
		endif
	else
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree - 1
		set this = ForGroupCallback_nextFree[ForGroupCallback_firstFree]
		set ForGroupCallback_typeId[this] = 652
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function group_destr takes group this returns nothing
	call DestroyGroup(this)
endfunction

function dealloc_ForGroupCallback takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[obj] == 0 then
		call error("Double free: object of type ForGroupCallback", "when calling error in ClosureForGroups, line 3")
	else
		set ForGroupCallback_nextFree[ForGroupCallback_firstFree] = obj
		set ForGroupCallback_firstFree = ForGroupCallback_firstFree + 1
		set ForGroupCallback_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyForGroupCallback takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dealloc_ForGroupCallback(this, "when calling dealloc_ForGroupCallback in ClosureForGroups, line 3")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_ForGroupCallback_destroyForGroupCallback takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ForGroupCallback_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling ForGroupCallback.ForGroupCallback", "when calling error in ClosureForGroups, line 3")
		else
			call error("Called ForGroupCallback.ForGroupCallback on invalid object.", "when calling error in ClosureForGroups, line 3")
		endif
	endif
	call destroyForGroupCallback(this, "when calling destroyForGroupCallback in ClosureForGroups, line 3")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function group_hasNext takes group this returns boolean
	return FirstOfGroup(this) != null
endfunction

function group_next takes group this returns unit
	local unit iterUnit = FirstOfGroup(this)
	call GroupRemoveUnit(this, iterUnit)
	set group_nexttempReturn = iterUnit
	set iterUnit = null
	return group_nexttempReturn
endfunction

function group_forEachFrom takes group this, integer cb, string w__wurst_stackPos returns nothing
	local unit u
	local group from
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set from = this
	loop
		exitwhen  not group_hasNext(from)
		set u = group_next(from)
		call dispatch_ForGroupCallback_ClosureForGroups_ForGroupCallback_callback(cb, u, "when calling callback in ClosureForGroups, line 40")
	endloop
	call dispatch_ForGroupCallback_destroyForGroupCallback(cb, "when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
	set wurst_stack_depth = wurst_stack_depth - 1
	set u = null
	set from = null
endfunction

function finishPreload takes string w__wurst_stackPos returns nothing
	local integer clVar
	local group temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call unit_remove(Preloader_dum)
	set temp = Preloader_dumg
	set clVar = alloc_ForGroupCallback_forEachFrom_Preloader("when calling alloc_ForGroupCallback_forEachFrom_Preloader in Preloader, line 46")
	call group_forEachFrom(temp, clVar, "when calling forEachFrom in Preloader, line 46")
	call group_destr(Preloader_dumg)
	set Preloader_dumg = null
	set wurst_stack_depth = wurst_stack_depth - 1
	set temp = null
endfunction

function call_nullTimer_Preloader takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call finishPreload("when calling finishPreload in Preloader, line 55")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackSingle_ClosureTimers_CallbackSingle_call takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling CallbackSingle.call", "when calling error in ClosureTimers, line 109")
		else
			call error("Called CallbackSingle.call on invalid object.", "when calling error in ClosureTimers, line 109")
		endif
	endif
	if CallbackSingle_typeId[this] <= 638 then
		if CallbackSingle_typeId[this] <= 637 then
			call call_doAfter_ClosureTimers(this)
		else
			call call_doAfter_ClosureTimers_278(this)
		endif
	elseif CallbackSingle_typeId[this] <= 639 then
		call call_doAfter_ClosureTimers_279(this)
	else
		call call_nullTimer_Preloader(this, "when calling call_nullTimer_Preloader in ClosureTimers, line 109")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function Table_loadInt takes integer this, integer parentKey returns integer
	return hashtable_loadInt(Table_ht, this, parentKey)
endfunction

function dispatch_Table_Table_Table_loadInt takes integer this, integer parentKey, string w__wurst_stackPos returns integer
	local integer Table_Table_loadInt_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.loadInt", "when calling error in Table, line 40")
		else
			call error("Called Table.loadInt on invalid object.", "when calling error in Table, line 40")
		endif
	endif
	set Table_Table_loadInt_result = Table_loadInt(this, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_loadInt_result
endfunction

function timer_getHandleId takes timer this returns integer
	return GetHandleId(this)
endfunction

function timer_getData takes timer this, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_loadInt(TimerUtils_timerData, timer_getHandleId(this), "when calling loadInt in TimerUtils, line 22")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function timer_pause takes timer this returns nothing
	call PauseTimer(this)
endfunction

function Table_saveInt takes integer this, integer parentKey, integer value returns nothing
	call hashtable_saveInt(Table_ht, this, parentKey, value)
endfunction

function dispatch_Table_Table_Table_saveInt takes integer this, integer parentKey, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.saveInt", "when calling error in Table, line 43")
		else
			call error("Called Table.saveInt on invalid object.", "when calling error in Table, line 43")
		endif
	endif
	call Table_saveInt(this, parentKey, value)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_setData takes timer this, integer data, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Table_Table_Table_saveInt(TimerUtils_timerData, timer_getHandleId(this), data, "when calling saveInt in TimerUtils, line 18")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_release takes timer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if this == null then
		call error("Trying to release a null timer", "when calling error in TimerUtils, line 38")
		set wurst_stack_depth = wurst_stack_depth - 1
		return
	endif
	if timer_getData(this, "when calling getData in TimerUtils, line 40") == TimerUtils_HELD then
		call error("ReleaseTimer: Double free!", "when calling error in TimerUtils, line 41")
		set wurst_stack_depth = wurst_stack_depth - 1
		return
	endif
	call timer_setData(this, TimerUtils_HELD, "when calling setData in TimerUtils, line 43")
	call timer_pause(this)
	set TimerUtils_freeTimers[TimerUtils_freeTimersCount] = this
	set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackSingle_onDestroy takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call timer_release(CallbackSingle_t[this], "when calling release in ClosureTimers, line 124")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dealloc_CallbackSingle takes integer obj, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[obj] == 0 then
		call error("Double free: object of type CallbackSingle", "when calling error in ClosureTimers, line 107")
	else
		set CallbackSingle_nextFree[CallbackSingle_firstFree] = obj
		set CallbackSingle_firstFree = CallbackSingle_firstFree + 1
		set CallbackSingle_typeId[obj] = 0
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function destroyCallbackSingle takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackSingle_onDestroy(this, "when calling CallbackSingle_onDestroy in ClosureTimers, line 123")
	call dealloc_CallbackSingle(this, "when calling dealloc_CallbackSingle in ClosureTimers, line 123")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_CallbackSingle_destroyCallbackSingle takes integer this, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling CallbackSingle.CallbackSingle", "when calling error in ClosureTimers, line 107")
		else
			call error("Called CallbackSingle.CallbackSingle on invalid object.", "when calling error in ClosureTimers, line 107")
		endif
	endif
	call destroyCallbackSingle(this, "when calling destroyCallbackSingle in ClosureTimers, line 107")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function CallbackSingle_staticCallback takes string w__wurst_stackPos returns nothing
	local timer t
	local integer cb
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set t = GetExpiredTimer()
	set cb = timer_getData(t, "when calling getData in ClosureTimers, line 119")
	call dispatch_CallbackSingle_ClosureTimers_CallbackSingle_call(cb, "when calling call in ClosureTimers, line 120")
	call dispatch_CallbackSingle_destroyCallbackSingle(cb, "when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121")
	set wurst_stack_depth = wurst_stack_depth - 1
	set t = null
endfunction

function code__start_CallbackSingle_ClosureTimers takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call CallbackSingle_staticCallback("when calling staticCallback in ClosureTimers, line 114")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function bridge_code__start_CallbackSingle_ClosureTimers takes nothing returns nothing
	set wurst_stack_depth = 0
	call code__start_CallbackSingle_ClosureTimers("via function reference ClosureTimers, line 114")
endfunction

function initializeTable takes string w__wurst_stackPos returns nothing
	local integer i
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set i = 0
	loop
		exitwhen i > 15
		call dispatch_Table_Table_Table_saveInt(Colors_decs, string_getHash(Colors_hexs[i]), i, "when calling saveInt in Colors, line 281")
		set i = i + 1
	endloop
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function alloc_Table takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_firstFree == 0 then
		if Table_maxIndex < 32768 then
			set Table_maxIndex = Table_maxIndex + 1
			set this = Table_maxIndex
			set Table_typeId[this] = 727
		else
			call error("Out of memory: Could not create Table.", "when calling error in Table, line 7")
			set this = 0
		endif
	else
		set Table_firstFree = Table_firstFree - 1
		set this = Table_nextFree[Table_firstFree]
		set Table_typeId[this] = 727
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function Table_init takes integer this returns nothing
endfunction

function construct_Table takes integer this returns nothing
	call Table_init(this)
endfunction

function new_Table takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this = alloc_Table("when calling alloc_Table in Table, line 6")
	call construct_Table(this)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function init_Colors takes string w__wurst_stackPos returns boolean
	local integer tuple_temp
	local integer tuple_temp_1
	local integer tuple_temp_2
	local integer tuple_temp_3
	local integer tuple_temp_4
	local integer tuple_temp_5
	local integer tuple_temp_6
	local integer tuple_temp_7
	local integer tuple_temp_8
	local integer tuple_temp_9
	local integer tuple_temp_10
	local integer tuple_temp_11
	local integer tuple_temp_12
	local integer tuple_temp_13
	local integer tuple_temp_14
	local integer tuple_temp_15
	local integer tuple_temp_16
	local integer tuple_temp_17
	local integer tuple_temp_18
	local integer tuple_temp_19
	local integer tuple_temp_20
	local integer tuple_temp_21
	local integer tuple_temp_22
	local integer tuple_temp_23
	local integer tuple_temp_24
	local integer tuple_temp_25
	local integer tuple_temp_26
	local integer tuple_temp_27
	local integer tuple_temp_28
	local integer tuple_temp_29
	local integer tuple_temp_30
	local integer tuple_temp_31
	local integer tuple_temp_32
	local integer tuple_temp_33
	local integer tuple_temp_34
	local integer tuple_temp_35
	local integer tuple_temp_36
	local integer tuple_temp_37
	local integer tuple_temp_38
	local integer tuple_temp_39
	local integer tuple_temp_40
	local integer tuple_temp_41
	local integer tuple_temp_42
	local integer tuple_temp_43
	local integer tuple_temp_44
	local integer tuple_temp_45
	local integer tuple_temp_46
	local integer tuple_temp_47
	local integer tuple_temp_48
	local integer tuple_temp_49
	local integer tuple_temp_50
	local integer tuple_temp_51
	local integer tuple_temp_52
	local integer tuple_temp_53
	local integer tuple_temp_54
	local integer tuple_temp_55
	local integer tuple_temp_56
	local integer tuple_temp_57
	local integer tuple_temp_58
	local integer tuple_temp_59
	local integer tuple_temp_60
	local integer tuple_temp_61
	local integer tuple_temp_62
	local integer tuple_temp_63
	local integer tuple_temp_64
	local integer tuple_temp_65
	local integer tuple_temp_66
	local integer tuple_temp_67
	local integer tuple_temp_68
	local integer tuple_temp_69
	local integer tuple_temp_70
	local integer tuple_temp_71
	local integer tuple_temp_72
	local integer tuple_temp_73
	local integer tuple_temp_74
	local integer tuple_temp_75
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set tuple_temp = 255
	set tuple_temp_1 = 255
	set tuple_temp_2 = 255
	set tuple_temp_3 = 255
	set Colors_COLOR_WHITE_red = tuple_temp
	set Colors_COLOR_WHITE_green = tuple_temp_1
	set Colors_COLOR_WHITE_blue = tuple_temp_2
	set Colors_COLOR_WHITE_alpha = tuple_temp_3
	set tuple_temp_4 = 255
	set tuple_temp_5 = 2
	set tuple_temp_6 = 2
	set Colors_PLAYER_COLORS_red[0] = tuple_temp_4
	set Colors_PLAYER_COLORS_green[0] = tuple_temp_5
	set Colors_PLAYER_COLORS_blue[0] = tuple_temp_6
	set tuple_temp_7 = 0
	set tuple_temp_8 = 65
	set tuple_temp_9 = 255
	set Colors_PLAYER_COLORS_red[1] = tuple_temp_7
	set Colors_PLAYER_COLORS_green[1] = tuple_temp_8
	set Colors_PLAYER_COLORS_blue[1] = tuple_temp_9
	set tuple_temp_10 = 27
	set tuple_temp_11 = 229
	set tuple_temp_12 = 184
	set Colors_PLAYER_COLORS_red[2] = tuple_temp_10
	set Colors_PLAYER_COLORS_green[2] = tuple_temp_11
	set Colors_PLAYER_COLORS_blue[2] = tuple_temp_12
	set tuple_temp_13 = 83
	set tuple_temp_14 = 0
	set tuple_temp_15 = 128
	set Colors_PLAYER_COLORS_red[3] = tuple_temp_13
	set Colors_PLAYER_COLORS_green[3] = tuple_temp_14
	set Colors_PLAYER_COLORS_blue[3] = tuple_temp_15
	set tuple_temp_16 = 255
	set tuple_temp_17 = 252
	set tuple_temp_18 = 0
	set Colors_PLAYER_COLORS_red[4] = tuple_temp_16
	set Colors_PLAYER_COLORS_green[4] = tuple_temp_17
	set Colors_PLAYER_COLORS_blue[4] = tuple_temp_18
	set tuple_temp_19 = 254
	set tuple_temp_20 = 137
	set tuple_temp_21 = 13
	set Colors_PLAYER_COLORS_red[5] = tuple_temp_19
	set Colors_PLAYER_COLORS_green[5] = tuple_temp_20
	set Colors_PLAYER_COLORS_blue[5] = tuple_temp_21
	set tuple_temp_22 = 31
	set tuple_temp_23 = 191
	set tuple_temp_24 = 0
	set Colors_PLAYER_COLORS_red[6] = tuple_temp_22
	set Colors_PLAYER_COLORS_green[6] = tuple_temp_23
	set Colors_PLAYER_COLORS_blue[6] = tuple_temp_24
	set tuple_temp_25 = 228
	set tuple_temp_26 = 90
	set tuple_temp_27 = 175
	set Colors_PLAYER_COLORS_red[7] = tuple_temp_25
	set Colors_PLAYER_COLORS_green[7] = tuple_temp_26
	set Colors_PLAYER_COLORS_blue[7] = tuple_temp_27
	set tuple_temp_28 = 148
	set tuple_temp_29 = 149
	set tuple_temp_30 = 150
	set Colors_PLAYER_COLORS_red[8] = tuple_temp_28
	set Colors_PLAYER_COLORS_green[8] = tuple_temp_29
	set Colors_PLAYER_COLORS_blue[8] = tuple_temp_30
	set tuple_temp_31 = 125
	set tuple_temp_32 = 190
	set tuple_temp_33 = 241
	set Colors_PLAYER_COLORS_red[9] = tuple_temp_31
	set Colors_PLAYER_COLORS_green[9] = tuple_temp_32
	set Colors_PLAYER_COLORS_blue[9] = tuple_temp_33
	set tuple_temp_34 = 15
	set tuple_temp_35 = 97
	set tuple_temp_36 = 69
	set Colors_PLAYER_COLORS_red[10] = tuple_temp_34
	set Colors_PLAYER_COLORS_green[10] = tuple_temp_35
	set Colors_PLAYER_COLORS_blue[10] = tuple_temp_36
	set tuple_temp_37 = 77
	set tuple_temp_38 = 41
	set tuple_temp_39 = 3
	set Colors_PLAYER_COLORS_red[11] = tuple_temp_37
	set Colors_PLAYER_COLORS_green[11] = tuple_temp_38
	set Colors_PLAYER_COLORS_blue[11] = tuple_temp_39
	set tuple_temp_40 = 155
	set tuple_temp_41 = 0
	set tuple_temp_42 = 0
	set Colors_PLAYER_COLORS_red[12] = tuple_temp_40
	set Colors_PLAYER_COLORS_green[12] = tuple_temp_41
	set Colors_PLAYER_COLORS_blue[12] = tuple_temp_42
	set tuple_temp_43 = 0
	set tuple_temp_44 = 0
	set tuple_temp_45 = 195
	set Colors_PLAYER_COLORS_red[13] = tuple_temp_43
	set Colors_PLAYER_COLORS_green[13] = tuple_temp_44
	set Colors_PLAYER_COLORS_blue[13] = tuple_temp_45
	set tuple_temp_46 = 0
	set tuple_temp_47 = 234
	set tuple_temp_48 = 255
	set Colors_PLAYER_COLORS_red[14] = tuple_temp_46
	set Colors_PLAYER_COLORS_green[14] = tuple_temp_47
	set Colors_PLAYER_COLORS_blue[14] = tuple_temp_48
	set tuple_temp_49 = 190
	set tuple_temp_50 = 0
	set tuple_temp_51 = 254
	set Colors_PLAYER_COLORS_red[15] = tuple_temp_49
	set Colors_PLAYER_COLORS_green[15] = tuple_temp_50
	set Colors_PLAYER_COLORS_blue[15] = tuple_temp_51
	set tuple_temp_52 = 235
	set tuple_temp_53 = 205
	set tuple_temp_54 = 135
	set Colors_PLAYER_COLORS_red[16] = tuple_temp_52
	set Colors_PLAYER_COLORS_green[16] = tuple_temp_53
	set Colors_PLAYER_COLORS_blue[16] = tuple_temp_54
	set tuple_temp_55 = 248
	set tuple_temp_56 = 164
	set tuple_temp_57 = 139
	set Colors_PLAYER_COLORS_red[17] = tuple_temp_55
	set Colors_PLAYER_COLORS_green[17] = tuple_temp_56
	set Colors_PLAYER_COLORS_blue[17] = tuple_temp_57
	set tuple_temp_58 = 191
	set tuple_temp_59 = 255
	set tuple_temp_60 = 128
	set Colors_PLAYER_COLORS_red[18] = tuple_temp_58
	set Colors_PLAYER_COLORS_green[18] = tuple_temp_59
	set Colors_PLAYER_COLORS_blue[18] = tuple_temp_60
	set tuple_temp_61 = 220
	set tuple_temp_62 = 185
	set tuple_temp_63 = 235
	set Colors_PLAYER_COLORS_red[19] = tuple_temp_61
	set Colors_PLAYER_COLORS_green[19] = tuple_temp_62
	set Colors_PLAYER_COLORS_blue[19] = tuple_temp_63
	set tuple_temp_64 = 40
	set tuple_temp_65 = 40
	set tuple_temp_66 = 40
	set Colors_PLAYER_COLORS_red[20] = tuple_temp_64
	set Colors_PLAYER_COLORS_green[20] = tuple_temp_65
	set Colors_PLAYER_COLORS_blue[20] = tuple_temp_66
	set tuple_temp_67 = 235
	set tuple_temp_68 = 240
	set tuple_temp_69 = 255
	set Colors_PLAYER_COLORS_red[21] = tuple_temp_67
	set Colors_PLAYER_COLORS_green[21] = tuple_temp_68
	set Colors_PLAYER_COLORS_blue[21] = tuple_temp_69
	set tuple_temp_70 = 0
	set tuple_temp_71 = 120
	set tuple_temp_72 = 30
	set Colors_PLAYER_COLORS_red[22] = tuple_temp_70
	set Colors_PLAYER_COLORS_green[22] = tuple_temp_71
	set Colors_PLAYER_COLORS_blue[22] = tuple_temp_72
	set tuple_temp_73 = 164
	set tuple_temp_74 = 111
	set tuple_temp_75 = 51
	set Colors_PLAYER_COLORS_red[23] = tuple_temp_73
	set Colors_PLAYER_COLORS_green[23] = tuple_temp_74
	set Colors_PLAYER_COLORS_blue[23] = tuple_temp_75
	set Colors_hexs[0] = "0"
	set Colors_hexs[1] = "1"
	set Colors_hexs[2] = "2"
	set Colors_hexs[3] = "3"
	set Colors_hexs[4] = "4"
	set Colors_hexs[5] = "5"
	set Colors_hexs[6] = "6"
	set Colors_hexs[7] = "7"
	set Colors_hexs[8] = "8"
	set Colors_hexs[9] = "9"
	set Colors_hexs[10] = "A"
	set Colors_hexs[11] = "B"
	set Colors_hexs[12] = "C"
	set Colors_hexs[13] = "D"
	set Colors_hexs[14] = "E"
	set Colors_hexs[15] = "F"
	set Colors_decs = new_Table("when calling new_Table in Colors, line 222")
	call initializeTable("when calling initializeTable in Colors, line 284")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Colors takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Colors("via function reference Colors, line 1")
endfunction

function createUnit takes player p, integer unitId, real pos_x, real pos_y, real facing_radians returns unit
	return CreateUnit(p, unitId, pos_x, pos_y, angle_degrees(facing_radians))
endfunction

function unit_addAbility takes unit this, integer abil returns boolean
	return UnitAddAbility(this, abil)
endfunction

function unit_removeAbility takes unit this, integer abil returns boolean
	return UnitRemoveAbility(this, abil)
endfunction

function createDummy takes real pos_x, real pos_y, player owner, real facing_radians returns unit
	local unit u = createUnit(owner, DummyRecycler_DUMMY_UNIT_ID, pos_x, pos_y, facing_radians)
	local unit receiver = u
	local unit receiver_1
	local unit receiver_2
	local unit receiver_3
	local unit receiver_4
	local unit receiver_5
	call unit_addAbility(receiver, Basics_HEIGHT_ENABLER)
	set receiver_1 = receiver
	call unit_removeAbility(receiver_1, Basics_HEIGHT_ENABLER)
	set receiver_2 = receiver_1
	call unit_addAbility(receiver_2, DummyRecycler_ROOT_ENABLER)
	set receiver_3 = receiver_2
	call unit_removeAbility(receiver_3, DummyRecycler_ROOT_ENABLER)
	set receiver_4 = receiver_3
	call unit_setXY(receiver_4, pos_x, pos_y)
	set receiver_5 = receiver_4
	call unit_setFacing(receiver_5, facing_radians)
	set createDummytempReturn = u
	set u = null
	set receiver = null
	set receiver_1 = null
	set receiver_2 = null
	set receiver_3 = null
	set receiver_4 = null
	set receiver_5 = null
	return createDummytempReturn
endfunction

function alloc_ArrayQueue takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if ArrayQueue_firstFree == 0 then
		if ArrayQueue_maxIndex < 32768 then
			set ArrayQueue_maxIndex = ArrayQueue_maxIndex + 1
			set this = ArrayQueue_maxIndex
			set ArrayQueue_typeId[this] = 628
		else
			call error("Out of memory: Could not create ArrayQueue.", "when calling error in DummyRecycler, line 60")
			set this = 0
		endif
	else
		set ArrayQueue_firstFree = ArrayQueue_firstFree - 1
		set this = ArrayQueue_nextFree[ArrayQueue_firstFree]
		set ArrayQueue_typeId[this] = 628
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function ArrayQueue_init takes integer this returns nothing
	set ArrayQueue_rp[this] = 0
	set ArrayQueue_size[this] = 0
endfunction

function construct_ArrayQueue takes integer this returns nothing
	call ArrayQueue_init(this)
endfunction

function new_ArrayQueue takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this = alloc_ArrayQueue("when calling alloc_ArrayQueue in DummyRecycler, line 60")
	call construct_ArrayQueue(this)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function init_DummyRecycler takes string w__wurst_stackPos returns boolean
	local integer i
	local integer temp
	local real facing_radians
	local integer j
	local integer temp_1
	local unit dummy
	local real tuple_temp
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set DummyRecycler_DUMMY_UNIT_ID = 2019849581
	set DummyRecycler_ROOT_ENABLER = 2020765556
	set DummyRecycler_DIFFERENT_ANGLES = 8
	set DummyRecycler_ANGLE_DEGREE = 360 * 1. / DummyRecycler_DIFFERENT_ANGLES
	set DummyRecycler_SAVED_UNITS_PER_ANGLE = 6
	set DelayNode_t = CreateTimer()
	set DelayNode_first = 0
	set i = 0
	set temp = DummyRecycler_DIFFERENT_ANGLES - 1
	loop
		exitwhen i > temp
		set DummyRecycler_angleQueues[i] = new_ArrayQueue("when calling new_ArrayQueue in DummyRecycler, line 153")
		set tuple_temp = i * DummyRecycler_ANGLE_DEGREE
		set facing_radians = tuple_temp
		set j = 0
		set temp_1 = DummyRecycler_SAVED_UNITS_PER_ANGLE - 1
		loop
			exitwhen j > temp_1
			set dummy = createDummy(vec2_op_minus(MapBounds_boundMax_x, MapBounds_boundMax_y, 16., 16.), vec2_op_minus_return_y, Basics_DUMMY_PLAYER, facing_radians)
			call dispatch_ArrayQueue_DummyRecycler_ArrayQueue_enqueue(DummyRecycler_angleQueues[i], dummy, "when calling enqueue in DummyRecycler, line 157")
			set j = j + 1
		endloop
		set i = i + 1
	endloop
	set wurst_stack_depth = wurst_stack_depth - 1
	set dummy = null
	return true
endfunction

function bridge_init_DummyRecycler takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_DummyRecycler("via function reference DummyRecycler, line 1")
endfunction

function alloc_HashMap takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_firstFree == 0 then
		if Table_maxIndex < 32768 then
			set Table_maxIndex = Table_maxIndex + 1
			set this = Table_maxIndex
			set Table_typeId[this] = 728
		else
			call error("Out of memory: Could not create HashMap.", "when calling error in HashMap, line 8")
			set this = 0
		endif
	else
		set Table_firstFree = Table_firstFree - 1
		set this = Table_nextFree[Table_firstFree]
		set Table_typeId[this] = 728
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function HashMap_init takes integer this returns nothing
	set HashMap_size[this] = 0
endfunction

function construct_HashMap takes integer this returns nothing
	call construct_Table(this)
	call HashMap_init(this)
endfunction

function new_HashMap takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this = alloc_HashMap("when calling alloc_HashMap in HashMap, line 7")
	call construct_HashMap(this)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function init_EventHelper takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call new_HashMap("when calling new_HashMap in EventHelper, line 7")
	call new_HashMap("when calling new_HashMap in EventHelper, line 8")
	call new_Table("when calling new_Table in EventHelper, line 9")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_EventHelper takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_EventHelper("via function reference EventHelper, line 1")
endfunction

function alloc_Comparator_LinkedList takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Comparator_firstFree == 0 then
		if Comparator_maxIndex < 32768 then
			set Comparator_maxIndex = Comparator_maxIndex + 1
			set this = Comparator_maxIndex
		else
			call error("Out of memory: Could not create Comparator_LinkedList.", "when calling error in LinkedList, line 533")
			set this = 0
		endif
	else
		set Comparator_firstFree = Comparator_firstFree - 1
		set this = Comparator_nextFree[Comparator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function alloc_Comparator_LinkedList_257 takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Comparator_firstFree == 0 then
		if Comparator_maxIndex < 32768 then
			set Comparator_maxIndex = Comparator_maxIndex + 1
			set this = Comparator_maxIndex
		else
			call error("Out of memory: Could not create Comparator_LinkedList.", "when calling error in LinkedList, line 537")
			set this = 0
		endif
	else
		set Comparator_firstFree = Comparator_firstFree - 1
		set this = Comparator_nextFree[Comparator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function realToIndex takes real r returns integer
	return real_toInt(r * TypeCasting_R2I_PRECISION)
endfunction

function init_LinkedList takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call alloc_Comparator_LinkedList("when calling alloc_Comparator_LinkedList in LinkedList, line 533")
	call alloc_Comparator_LinkedList_257("when calling alloc_Comparator_LinkedList in LinkedList, line 537")
	call realToIndex(0.)
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_LinkedList takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_LinkedList("via function reference LinkedList, line 1")
endfunction

function HashMap_get takes integer this, integer key, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_loadInt(this, key, "when calling loadInt in HashMap, line 24")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashMap_HashMap_HashMap_get takes integer this, integer key, string w__wurst_stackPos returns integer
	local integer HashMap_HashMap_get_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashMap.get", "when calling error in HashMap, line 23")
		else
			call error("Called HashMap.get on invalid object.", "when calling error in HashMap, line 23")
		endif
	endif
	set HashMap_HashMap_get_result = HashMap_get(this, key, "when calling get in HashMap, line 23")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_HashMap_get_result
endfunction

function Table_hasInt takes integer this, integer parentKey returns boolean
	return hashtable_hasInt(Table_ht, this, parentKey)
endfunction

function dispatch_Table_Table_Table_hasInt takes integer this, integer parentKey, string w__wurst_stackPos returns boolean
	local boolean Table_Table_hasInt_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.hasInt", "when calling error in Table, line 10")
		else
			call error("Called Table.hasInt on invalid object.", "when calling error in Table, line 10")
		endif
	endif
	set Table_Table_hasInt_result = Table_hasInt(this, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_hasInt_result
endfunction

function HashMap_has takes integer this, integer key, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_Table_Table_Table_hasInt(this, key, "when calling hasInt in HashMap, line 14")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashMap_HashMap_HashMap_has takes integer this, integer key, string w__wurst_stackPos returns boolean
	local boolean HashMap_HashMap_has_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashMap.has", "when calling error in HashMap, line 13")
		else
			call error("Called HashMap.has on invalid object.", "when calling error in HashMap, line 13")
		endif
	endif
	set HashMap_HashMap_has_result = HashMap_has(this, key, "when calling has in HashMap, line 13")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_HashMap_has_result
endfunction

function hashtable_hasString takes hashtable this, integer parentKey, integer childKey returns boolean
	return HaveSavedString(this, parentKey, childKey)
endfunction

function Table_hasString takes integer this, integer parentKey returns boolean
	return hashtable_hasString(Table_ht, this, parentKey)
endfunction

function dispatch_Table_Table_Table_hasString takes integer this, integer parentKey, string w__wurst_stackPos returns boolean
	local boolean Table_Table_hasString_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.hasString", "when calling error in Table, line 19")
		else
			call error("Called Table.hasString on invalid object.", "when calling error in Table, line 19")
		endif
	endif
	set Table_Table_hasString_result = Table_hasString(this, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_hasString_result
endfunction

function hashtable_loadString takes hashtable this, integer parentKey, integer childKey returns string
	return LoadStr(this, parentKey, childKey)
endfunction

function Table_loadString takes integer this, integer parentKey returns string
	return hashtable_loadString(Table_ht, this, parentKey)
endfunction

function dispatch_Table_Table_Table_loadString takes integer this, integer parentKey, string w__wurst_stackPos returns string
	local string Table_Table_loadString_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.loadString", "when calling error in Table, line 58")
		else
			call error("Called Table.loadString on invalid object.", "when calling error in Table, line 58")
		endif
	endif
	set Table_Table_loadString_result = Table_loadString(this, parentKey)
	set wurst_stack_depth = wurst_stack_depth - 1
	return Table_Table_loadString_result
endfunction

function hashtable_saveString takes hashtable this, integer parentKey, integer childKey, string value returns nothing
	call SaveStr(this, parentKey, childKey, value)
endfunction

function Table_saveString takes integer this, integer parentKey, string value returns nothing
	call hashtable_saveString(Table_ht, this, parentKey, value)
endfunction

function dispatch_Table_Table_Table_saveString takes integer this, integer parentKey, string value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling Table.saveString", "when calling error in Table, line 61")
		else
			call error("Called Table.saveString on invalid object.", "when calling error in Table, line 61")
		endif
	endif
	call Table_saveString(this, parentKey, value)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function stringToIndex takes string s, string w__wurst_stackPos returns integer
	local integer hash
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set hash = string_getHash(s)
	loop
		exitwhen  not true
		if dispatch_Table_Table_Table_hasString(TypeCasting_typecastdata, hash, "when calling hasString in TypeCasting, line 26") then
			if dispatch_Table_Table_Table_loadString(TypeCasting_typecastdata, hash, "when calling loadString in TypeCasting, line 27") == s then
				exitwhen true
			endif
		else
			call dispatch_Table_Table_Table_saveString(TypeCasting_typecastdata, hash, s, "when calling saveString in TypeCasting, line 30")
			exitwhen true
		endif
		set hash = hash + 1
	endloop
	set wurst_stack_depth = wurst_stack_depth - 1
	return hash
endfunction

function string_length takes string this returns integer
	return StringLength(this)
endfunction

function string_substring takes string this, integer start, integer stop returns string
	return SubString(this, start, stop)
endfunction

function string_indexOf takes string this, string s returns integer
	local integer i = 0
	local integer temp = string_length(this) - string_length(s)
	loop
		exitwhen i > temp
		if string_substring(this, i, i + string_length(s)) == s then
			return i
		endif
		set i = i + 1
	endloop
	return -1
endfunction

function string_indexOf_438 takes string this, string s, integer startpos returns integer
	local integer i = startpos
	local integer temp = string_length(this) - string_length(s)
	loop
		exitwhen i > temp
		if string_substring(this, i, i + string_length(s)) == s then
			return i
		endif
		set i = i + 1
	endloop
	return -1
endfunction

function string_replace takes string this, string oldSubstring, string newSubstring returns string
	local string s = this
	local integer i
	if string_length(oldSubstring) > 0 then
		set i = string_indexOf(this, oldSubstring)
		loop
			exitwhen  not (i != -1)
			set s = string_substring(s, 0, i) + newSubstring + string_substring(s, i + string_length(oldSubstring), string_length(s))
			set i = string_indexOf_438(s, oldSubstring, i + string_length(newSubstring))
		endloop
	endif
	return s
endfunction

function string_format_1 takes string this, string replacements_0 returns string
	local string result_1 = this
	local integer i = 0
	set result_1 = string_replace(result_1, "{" + int_toString(i) + "}", replacements_0)
	set i = i + 1
	return result_1
endfunction

function string_toUpperCase takes string this returns string
	return StringCase(this, true)
endfunction

function inferType takes string name, string w__wurst_stackPos returns integer
	local string key
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set key = string_toUpperCase(string_substring(name, 0, 5))
	if  not dispatch_HashMap_HashMap_HashMap_has(ObjectIDManager_shortcuts, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 56"), "when calling has in ObjectIDManager, line 56") then
		call error(string_format_1("Invalid shortcut used: {}", name), "when calling error in ObjectIDManager, line 57")
	endif
	set stackTrace_tempReturn = dispatch_HashMap_HashMap_HashMap_get(ObjectIDManager_shortcuts, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 60"), "when calling get in ObjectIDManager, line 60")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function HashMap_put takes integer this, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if  not dispatch_HashMap_HashMap_HashMap_has(this, key, "when calling has in HashMap, line 18") then
		set HashMap_size[this] = HashMap_size[this] + 1
	endif
	call dispatch_Table_Table_Table_saveInt(this, key, value, "when calling saveInt in HashMap, line 20")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_count takes integer this, integer elem returns integer
	return hashtable_loadInt(HashList_occurences, this, elem)
endfunction

function dispatch_HashList_HashList_HashList_count takes integer this, integer elem, string w__wurst_stackPos returns integer
	local integer HashList_HashList_count_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashList.count", "when calling error in HashList, line 28")
		else
			call error("Called HashList.count on invalid object.", "when calling error in HashList, line 28")
		endif
	endif
	set HashList_HashList_count_result = HashList_count(this, elem)
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_count_result
endfunction

function HashList_incrOccurences takes integer this, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call hashtable_saveInt(HashList_occurences, this, elem, dispatch_HashList_HashList_HashList_count(this, elem, "when calling count in HashList, line 35") + 1)
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashList_HashList_HashList_incrOccurences takes integer this, integer elem, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashList.incrOccurences", "when calling error in HashList, line 34")
		else
			call error("Called HashList.incrOccurences on invalid object.", "when calling error in HashList, line 34")
		endif
	endif
	call HashList_incrOccurences(this, elem, "when calling incrOccurences in HashList, line 34")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_add_1 takes integer this, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call hashtable_saveInt(HashList_ht, this, HashList_size[this], elems_0)
	call dispatch_HashList_HashList_HashList_incrOccurences(this, elems_0, "when calling incrOccurences in HashList, line 44")
	set HashList_size[this] = HashList_size[this] + 1
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashList_HashList_HashList_add_1 takes integer this, integer elems_0, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashList.add", "when calling error in HashList, line 41")
		else
			call error("Called HashList.add on invalid object.", "when calling error in HashList, line 41")
		endif
	endif
	call HashList_add_1(this, elems_0, "when calling add in HashList, line 41")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function HashList_has takes integer this, integer elem, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_HashList_HashList_HashList_count(this, elem, "when calling count in HashList, line 109") > 0
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_HashList_HashList_HashList_has takes integer this, integer elem, string w__wurst_stackPos returns boolean
	local boolean HashList_HashList_has_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if HashList_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashList.has", "when calling error in HashList, line 108")
		else
			call error("Called HashList.has on invalid object.", "when calling error in HashList, line 108")
		endif
	endif
	set HashList_HashList_has_result = HashList_has(this, elem, "when calling has in HashList, line 108")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashList_HashList_has_result
endfunction

function IterableMap_hasKey takes integer this, integer key, string w__wurst_stackPos returns boolean
	local boolean stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = dispatch_HashList_HashList_HashList_has(IterableMap_keys[this], key, "when calling has in HashMap, line 88")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function dispatch_IterableMap_HashMap_IterableMap_hasKey takes integer this, integer key, string w__wurst_stackPos returns boolean
	local boolean HashMap_IterableMap_hasKey_result
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling IterableMap.hasKey", "when calling error in HashMap, line 87")
		else
			call error("Called IterableMap.hasKey on invalid object.", "when calling error in HashMap, line 87")
		endif
	endif
	set HashMap_IterableMap_hasKey_result = IterableMap_hasKey(this, key, "when calling hasKey in HashMap, line 87")
	set wurst_stack_depth = wurst_stack_depth - 1
	return HashMap_IterableMap_hasKey_result
endfunction

function IterableMap_put takes integer this, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call HashMap_put(this, key, value, "when calling put in HashMap, line 60")
	if  not dispatch_IterableMap_HashMap_IterableMap_hasKey(this, key, "when calling hasKey in HashMap, line 61") then
		call dispatch_HashList_HashList_HashList_add_1(IterableMap_keys[this], key, "when calling add in HashMap, line 62")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function dispatch_HashMap_HashMap_HashMap_put takes integer this, integer key, integer value, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if Table_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling HashMap.put", "when calling error in HashMap, line 17")
		else
			call error("Called HashMap.put on invalid object.", "when calling error in HashMap, line 17")
		endif
	endif
	if Table_typeId[this] <= 728 then
		call HashMap_put(this, key, value, "when calling put in HashMap, line 17")
	else
		call IterableMap_put(this, key, value, "when calling put in HashMap, line 17")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function int_registerObjectID_413 takes integer this, string name, integer type_u, string w__wurst_stackPos returns nothing
	local string key
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set key = string_toUpperCase(name)
	if dispatch_HashMap_HashMap_HashMap_has(ObjectIDManager_values, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 78"), "when calling has in ObjectIDManager, line 78") then
		call error(string_format_1("Duplicate name detected: {}", name), "when calling error in ObjectIDManager, line 79")
	endif
	call dispatch_HashMap_HashMap_HashMap_put(ObjectIDManager_values, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 82"), this, "when calling put in ObjectIDManager, line 82")
	call dispatch_HashMap_HashMap_HashMap_put(ObjectIDManager_types, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 83"), type_u, "when calling put in ObjectIDManager, line 83")
	call dispatch_HashMap_HashMap_HashMap_put(ObjectIDManager_names, this, stringToIndex(key, "when calling stringToIndex in ObjectIDManager, line 84"), "when calling put in ObjectIDManager, line 84")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function int_registerObjectID takes integer this, string name, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call int_registerObjectID_413(this, name, inferType(name, "when calling inferType in ObjectIDManager, line 71"), "when calling registerObjectID in ObjectIDManager, line 71")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function init_LocalObjectIDs takes string w__wurst_stackPos returns boolean
	local integer receiver
	local integer receiver_1
	local integer receiver_2
	local integer receiver_3
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set receiver = 1213018161
	call int_registerObjectID(receiver, "UNIT_FOUNDER", "when calling registerObjectID in LocalObjectIDs, line 11")
	set LocalObjectIDs_UNIT_FOUNDER = receiver
	set receiver_1 = 2016423985
	call int_registerObjectID(receiver_1, "UNIT_BUILDING_TENT", "when calling registerObjectID in LocalObjectIDs, line 17")
	set receiver_2 = 2016423986
	call int_registerObjectID(receiver_2, "UNIT_BUILDING_CAMPFIRE", "when calling registerObjectID in LocalObjectIDs, line 18")
	set receiver_3 = 2016423987
	call int_registerObjectID(receiver_3, "UNIT_BUILDING_LAMP", "when calling registerObjectID in LocalObjectIDs, line 19")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_LocalObjectIDs takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_LocalObjectIDs("via function reference LocalObjectIDs, line 1")
endfunction

function alloc_IdGenerator takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if IdGenerator_firstFree == 0 then
		if IdGenerator_maxIndex < 32768 then
			set IdGenerator_maxIndex = IdGenerator_maxIndex + 1
			set this = IdGenerator_maxIndex
		else
			call error("Out of memory: Could not create IdGenerator.", "when calling error in ObjectIdGenerator, line 13")
			set this = 0
		endif
	else
		set IdGenerator_firstFree = IdGenerator_firstFree - 1
		set this = IdGenerator_nextFree[IdGenerator_firstFree]
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function IdGenerator_init takes integer this returns nothing
endfunction

function construct_IdGenerator takes integer this, integer start returns nothing
	call IdGenerator_init(this)
endfunction

function new_IdGenerator takes integer start, string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set this = alloc_IdGenerator("when calling alloc_IdGenerator in ObjectIdGenerator, line 19")
	call construct_IdGenerator(this, start)
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function init_ObjectIDManager takes string w__wurst_stackPos returns boolean
	local integer receiver
	local integer receiver_1
	local integer receiver_2
	local integer receiver_3
	local integer receiver_4
	local integer receiver_5
	local integer receiver_6
	local integer receiver_7
	local integer receiver_8
	local integer receiver_9
	local integer receiver_10
	local integer receiver_11
	local integer receiver_12
	local integer receiver_13
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set ObjectIDManager_DEST_ID_GEN = new_IdGenerator(1145909296, "when calling new_IdGenerator in ObjectIDManager, line 11")
	set receiver = new_HashMap("when calling new_HashMap in ObjectIDManager, line 23")
	call dispatch_HashMap_HashMap_HashMap_put(receiver, stringToIndex("UNIT_", "when calling stringToIndex in ObjectIDManager, line 24"), 0, "when calling put in ObjectIDManager, line 24")
	set receiver_1 = receiver
	call dispatch_HashMap_HashMap_HashMap_put(receiver_1, stringToIndex("HERO_", "when calling stringToIndex in ObjectIDManager, line 25"), 1, "when calling put in ObjectIDManager, line 25")
	set receiver_2 = receiver_1
	call dispatch_HashMap_HashMap_HashMap_put(receiver_2, stringToIndex("ABIL_", "when calling stringToIndex in ObjectIDManager, line 26"), 2, "when calling put in ObjectIDManager, line 26")
	set receiver_3 = receiver_2
	call dispatch_HashMap_HashMap_HashMap_put(receiver_3, stringToIndex("BUFF_", "when calling stringToIndex in ObjectIDManager, line 27"), 3, "when calling put in ObjectIDManager, line 27")
	set receiver_4 = receiver_3
	call dispatch_HashMap_HashMap_HashMap_put(receiver_4, stringToIndex("ITEM_", "when calling stringToIndex in ObjectIDManager, line 28"), 4, "when calling put in ObjectIDManager, line 28")
	set receiver_5 = receiver_4
	call dispatch_HashMap_HashMap_HashMap_put(receiver_5, stringToIndex("UPGD_", "when calling stringToIndex in ObjectIDManager, line 29"), 5, "when calling put in ObjectIDManager, line 29")
	set receiver_6 = receiver_5
	call dispatch_HashMap_HashMap_HashMap_put(receiver_6, stringToIndex("DEST_", "when calling stringToIndex in ObjectIDManager, line 30"), 6, "when calling put in ObjectIDManager, line 30")
	set ObjectIDManager_shortcuts = receiver_6
	set receiver_7 = new_HashMap("when calling new_HashMap in ObjectIDManager, line 33")
	call dispatch_HashMap_HashMap_HashMap_put(receiver_7, 0, ObjectIdGenerator_UNIT_ID_GEN, "when calling put in ObjectIDManager, line 34")
	set receiver_8 = receiver_7
	call dispatch_HashMap_HashMap_HashMap_put(receiver_8, 1, ObjectIdGenerator_HERO_ID_GEN, "when calling put in ObjectIDManager, line 35")
	set receiver_9 = receiver_8
	call dispatch_HashMap_HashMap_HashMap_put(receiver_9, 2, ObjectIdGenerator_ABIL_ID_GEN, "when calling put in ObjectIDManager, line 36")
	set receiver_10 = receiver_9
	call dispatch_HashMap_HashMap_HashMap_put(receiver_10, 3, ObjectIdGenerator_BUFF_ID_GEN, "when calling put in ObjectIDManager, line 37")
	set receiver_11 = receiver_10
	call dispatch_HashMap_HashMap_HashMap_put(receiver_11, 4, ObjectIdGenerator_ITEM_ID_GEN, "when calling put in ObjectIDManager, line 38")
	set receiver_12 = receiver_11
	call dispatch_HashMap_HashMap_HashMap_put(receiver_12, 5, ObjectIdGenerator_UPGD_ID_GEN, "when calling put in ObjectIDManager, line 39")
	set receiver_13 = receiver_12
	call dispatch_HashMap_HashMap_HashMap_put(receiver_13, 6, ObjectIDManager_DEST_ID_GEN, "when calling put in ObjectIDManager, line 40")
	set ObjectIDManager_values = new_HashMap("when calling new_HashMap in ObjectIDManager, line 43")
	set ObjectIDManager_types = new_HashMap("when calling new_HashMap in ObjectIDManager, line 46")
	set ObjectIDManager_names = new_HashMap("when calling new_HashMap in ObjectIDManager, line 49")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_ObjectIDManager takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ObjectIDManager("via function reference ObjectIDManager, line 1")
endfunction

function init_ObjectIdGenerator takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set ObjectIdGenerator_UNIT_ID_GEN = new_IdGenerator(2016423984, "when calling new_IdGenerator in ObjectIdGenerator, line 6")
	set ObjectIdGenerator_HERO_ID_GEN = new_IdGenerator(1213018160, "when calling new_IdGenerator in ObjectIdGenerator, line 7")
	set ObjectIdGenerator_ABIL_ID_GEN = new_IdGenerator(1095577648, "when calling new_IdGenerator in ObjectIdGenerator, line 8")
	set ObjectIdGenerator_BUFF_ID_GEN = new_IdGenerator(1112354864, "when calling new_IdGenerator in ObjectIdGenerator, line 9")
	set ObjectIdGenerator_ITEM_ID_GEN = new_IdGenerator(1229795376, "when calling new_IdGenerator in ObjectIdGenerator, line 10")
	set ObjectIdGenerator_UPGD_ID_GEN = new_IdGenerator(1380790320, "when calling new_IdGenerator in ObjectIdGenerator, line 11")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_ObjectIdGenerator takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_ObjectIdGenerator("via function reference ObjectIdGenerator, line 1")
endfunction

function alloc_CallbackSingle_nullTimer_Preloader takes string w__wurst_stackPos returns integer
	local integer this
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_firstFree == 0 then
		if CallbackSingle_maxIndex < 32768 then
			set CallbackSingle_maxIndex = CallbackSingle_maxIndex + 1
			set this = CallbackSingle_maxIndex
			set CallbackSingle_typeId[this] = 640
		else
			call error("Out of memory: Could not create CallbackSingle_nullTimer_Preloader.", "when calling error in Preloader, line 55")
			set this = 0
		endif
	else
		set CallbackSingle_firstFree = CallbackSingle_firstFree - 1
		set this = CallbackSingle_nextFree[CallbackSingle_firstFree]
		set CallbackSingle_typeId[this] = 640
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return this
endfunction

function CallbackSingle_init takes integer this returns nothing
endfunction

function construct_CallbackSingle takes integer this returns nothing
	call CallbackSingle_init(this)
endfunction

function getTimer takes string w__wurst_stackPos returns timer
	local timer receiver
	local timer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if TimerUtils_freeTimersCount > 0 then
		set TimerUtils_freeTimersCount = TimerUtils_freeTimersCount - 1
		call timer_setData(TimerUtils_freeTimers[TimerUtils_freeTimersCount], 0, "when calling setData in TimerUtils, line 30")
		set wurst_stack_depth = wurst_stack_depth - 1
		set receiver = null
		set stackTrace_tempReturn = null
		return TimerUtils_freeTimers[TimerUtils_freeTimersCount]
	else
		set receiver = CreateTimer()
		call timer_setData(receiver, 0, "when calling setData in TimerUtils, line 33")
		set stackTrace_tempReturn = receiver
		set wurst_stack_depth = wurst_stack_depth - 1
		set getTimertempReturn = stackTrace_tempReturn
		set receiver = null
		set stackTrace_tempReturn = null
		return getTimertempReturn
	endif
endfunction

function CallbackSingle_start takes integer this, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	local timer receiver
	local timer receiver_1
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set receiver = whichTimer
	call timer_setData(receiver, this, "when calling setData in ClosureTimers, line 113")
	set receiver_1 = receiver
	call timer_start(receiver_1, time, ref_function_bridge_code__start_CallbackSingle_ClosureTimers)
	set CallbackSingle_t[this] = receiver_1
	set wurst_stack_depth = wurst_stack_depth - 1
	set receiver = null
	set receiver_1 = null
endfunction

function dispatch_CallbackSingle_ClosureTimers_CallbackSingle_start takes integer this, timer whichTimer, real time, string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	if CallbackSingle_typeId[this] == 0 then
		if this == 0 then
			call error("Nullpointer exception when calling CallbackSingle.start", "when calling error in ClosureTimers, line 111")
		else
			call error("Called CallbackSingle.start on invalid object.", "when calling error in ClosureTimers, line 111")
		endif
	endif
	call CallbackSingle_start(this, whichTimer, time, "when calling start in ClosureTimers, line 111")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function timer_doAfter takes timer this, real timeToWait, integer cb, string w__wurst_stackPos returns integer
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_CallbackSingle_ClosureTimers_CallbackSingle_start(cb, this, timeToWait, "when calling start in ClosureTimers, line 16")
	set wurst_stack_depth = wurst_stack_depth - 1
	return cb
endfunction

function doAfter takes real timeToWait, integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = timer_doAfter(getTimer("when calling getTimer in ClosureTimers, line 27"), timeToWait, cb, "when calling doAfter in ClosureTimers, line 27")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function nullTimer takes integer cb, string w__wurst_stackPos returns integer
	local integer stackTrace_tempReturn
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set stackTrace_tempReturn = doAfter(0., cb, "when calling doAfter in ClosureTimers, line 33")
	set wurst_stack_depth = wurst_stack_depth - 1
	return stackTrace_tempReturn
endfunction

function init_Preloader takes string w__wurst_stackPos returns boolean
	local integer clVar
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set Preloader_autoFinish = true
	set Preloader_dumg = CreateGroup()
	set Preloader_dum = createUnit(Basics_DUMMY_PLAYER, DummyRecycler_DUMMY_UNIT_ID, 0., 0., 0.)
	if Preloader_autoFinish then
		set clVar = alloc_CallbackSingle_nullTimer_Preloader("when calling alloc_CallbackSingle_nullTimer_Preloader in Preloader, line 55")
		call construct_CallbackSingle(clVar)
		call nullTimer(clVar, "when calling nullTimer in Preloader, line 55")
	endif
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_Preloader takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_Preloader("via function reference Preloader, line 1")
endfunction

function init_TimerUtils takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set TimerUtils_freeTimersCount = 0
	set TimerUtils_timerData = new_Table("when calling new_Table in TimerUtils, line 13")
	set TimerUtils_HELD = 679645218
	call new_HashMap("when calling new_HashMap in TimerUtils, line 59")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_TimerUtils takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_TimerUtils("via function reference TimerUtils, line 1")
endfunction

function initTypecastData takes string w__wurst_stackPos returns nothing
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	call dispatch_Table_Table_Table_saveString(TypeCasting_typecastdata, 0, "", "when calling saveString in TypeCasting, line 12")
	set wurst_stack_depth = wurst_stack_depth - 1
endfunction

function init_TypeCasting takes string w__wurst_stackPos returns boolean
	set wurst_stack[wurst_stack_depth] = w__wurst_stackPos
	set wurst_stack_depth = wurst_stack_depth + 1
	set TypeCasting_typecastdata = new_Table("when calling new_Table in TypeCasting, line 7")
	set TypeCasting_R2I_PRECISION = 1000.
	call initTypecastData("when calling initTypecastData in TypeCasting, line 15")
	set wurst_stack_depth = wurst_stack_depth - 1
	return true
endfunction

function bridge_init_TypeCasting takes nothing returns boolean
	set wurst_stack_depth = 0
	return init_TypeCasting("via function reference TypeCasting, line 1")
endfunction

function code__startPeriodic_GameTimer takes nothing returns nothing
	set GameTimer_currentTime = GameTimer_currentTime + Basics_ANIMATION_PERIOD
endfunction

function init_Abilities takes nothing returns boolean
	return true
endfunction

function init_AbilityIds takes nothing returns boolean
	return true
endfunction

function init_AbilityObjEditing takes nothing returns boolean
	return true
endfunction

function init_Angle takes nothing returns boolean
	set Angle_DEGTORAD = 0.017453293
	set Angle_RADTODEG = 57.295779513
	return true
endfunction

function init_AttachmentPoints takes nothing returns boolean
	return true
endfunction

function init_Basics takes nothing returns boolean
	set Basics_ANIMATION_PERIOD = 0.030
	set Basics_HEIGHT_ENABLER = 1097691750
	set Basics_DUMMY_PLAYER = Player_players[PLAYER_NEUTRAL_PASSIVE]
	return true
endfunction

function int_bitOr takes integer this, integer other returns integer
	return BlzBitOr(this, other)
endfunction

function int_bitXor takes integer this, integer other returns integer
	return BlzBitXor(this, other)
endfunction

function initPows takes nothing returns nothing
	local integer allPows
	local integer i
	local integer temp
	local integer i_1
	local integer temp_1
	set BitSet_pows[0] = 1
	set allPows = 1
	set i = 1
	set temp = BitSet_BITSET_SIZE - 1
	loop
		exitwhen i > temp
		set BitSet_pows[i] = BitSet_pows[i - 1] * 2
		set allPows = int_bitOr(allPows, BitSet_pows[i])
		set i = i + 1
	endloop
	set i_1 = 0
	set temp_1 = BitSet_BITSET_SIZE - 1
	loop
		exitwhen i_1 > temp_1
		call int_bitXor(allPows, BitSet_pows[i_1])
		set i_1 = i_1 + 1
	endloop
endfunction

function init_BitSet takes nothing returns boolean
	set BitSet_BITSET_SIZE = 32
	call initPows()
	return true
endfunction

function init_Buildings takes nothing returns boolean
	return true
endfunction

function init_ClosureForGroups takes nothing returns boolean
	local real tuple_temp
	local real tuple_temp_1
	call CreateGroup()
	set ClosureForGroups_tempCallbacksCount = 0
	set ClosureForGroups_maxCount = Integer_INT_MAX
	set ClosureForGroups_iterCount = 0
	call Filter(ref_function_bridge_code__Filter_ClosureForGroups)
	call Rect(0., 0., 0., 0.)
	set tuple_temp = Vectors_ZERO2_x
	set tuple_temp_1 = Vectors_ZERO2_y
	return true
endfunction

function init_ClosureTimers takes nothing returns boolean
	set ClosureTimers_x = 200
	return true
endfunction

function init_Destructable takes nothing returns boolean
	return true
endfunction

function init_Doodads takes nothing returns boolean
	return true
endfunction

function init_ErrorHandling takes nothing returns boolean
	set ErrorHandling_MUTE_ERROR_DURATION = 60
	set ErrorHandling_PRIMARY_ERROR_KEY = -1
	set ErrorHandling_HT = hashtable_compiletime
	set ErrorHandling_suppressErrorMessages = false
	return true
endfunction

function playerFromIndex takes integer index returns player
	return Player_players[index]
endfunction

function player_getSlotState takes player this returns playerslotstate
	return GetPlayerSlotState(this)
endfunction

function player_getStartLocation takes player this returns real
	set player_getStartLocation_return_x = GetPlayerStartLocationX(this)
	set player_getStartLocation_return_y = GetPlayerStartLocationY(this)
	return player_getStartLocation_return_x
endfunction

function init_Founder takes nothing returns boolean
	local integer playerIndex = 0
	local integer temp = PLAYER_NEUTRAL_AGGRESSIVE - 1
	local player whichPlayer
	loop
		exitwhen playerIndex > temp
		set whichPlayer = playerFromIndex(playerIndex)
		if player_getSlotState(whichPlayer) == PLAYER_SLOT_STATE_PLAYING and ( not IsPlayerObserver(whichPlayer)) then
			call createUnit(whichPlayer, LocalObjectIDs_UNIT_FOUNDER, player_getStartLocation(whichPlayer), player_getStartLocation_return_y, real_asAngleDegrees(270.0))
		endif
		set playerIndex = playerIndex + 1
	endloop
	set whichPlayer = null
	return true
endfunction

function createFrame takes string typeName, string name, framehandle owner, string inherits, integer createContext returns framehandle
	return BlzCreateFrameByType(typeName, name, owner, inherits, createContext)
endfunction

function framehandle_setSize takes framehandle this, real width, real height returns nothing
	call BlzFrameSetSize(this, width, height)
endfunction

function init_Framehandle takes nothing returns boolean
	local framehandle receiver
	set Framehandle_GAME_UI = BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0)
	set receiver = createFrame("FRAME", "SetMousePositionCage", Framehandle_GAME_UI, null, 0)
	call framehandle_setSize(receiver, 0.0001, 0.0001)
	set receiver = null
	return true
endfunction

function timer_startPeriodic takes timer this, real time, code timerCallBack returns nothing
	call TimerStart(this, time, true, timerCallBack)
endfunction

function init_GameTimer takes nothing returns boolean
	set GameTimer_gameTimer = CreateTimer()
	call timer_start(GameTimer_gameTimer, 100000., null)
	call timer_startPeriodic(CreateTimer(), Basics_ANIMATION_PERIOD, ref_function_code__startPeriodic_GameTimer)
	return true
endfunction

function init_Group takes nothing returns boolean
	call CreateGroup()
	return true
endfunction

function init_HashList takes nothing returns boolean
	set HashList_ht = hashtable_compiletime_245
	set HashList_occurences = hashtable_compiletime_246
	return true
endfunction

function init_Icons takes nothing returns boolean
	return true
endfunction

function init_Integer takes nothing returns boolean
	set Integer_INT_MAX = 2147483647
	return true
endfunction

function init_Lightning takes nothing returns boolean
	return true
endfunction

function init_MagicFunctions takes nothing returns boolean
	set MagicFunctions_compiletime = false
	return true
endfunction

function rect_getMaxX takes rect this returns real
	return GetRectMaxX(this)
endfunction

function rect_getMaxY takes rect this returns real
	return GetRectMaxY(this)
endfunction

function rect_getMinX takes rect this returns real
	return GetRectMinX(this)
endfunction

function rect_getMinY takes rect this returns real
	return GetRectMinY(this)
endfunction

function region_addRect takes region this, rect rct returns nothing
	call RegionAddRect(this, rct)
endfunction

function vec2_op_mult takes real this_x, real this_y, real factor returns real
	set vec2_op_mult_return_x = this_x * factor
	set vec2_op_mult_return_y = this_y * factor
	return vec2_op_mult_return_x
endfunction

function vec2_op_plus takes real this_x, real this_y, real v_x, real v_y returns real
	set vec2_op_plus_return_x = this_x + v_x
	set vec2_op_plus_return_y = this_y + v_y
	return vec2_op_plus_return_x
endfunction

function initMapBounds takes nothing returns nothing
	local rect cond_result
	local region receiver
	local rect cond_result_1
	local region receiver_1
	local real tuple_temp
	local real tuple_temp_1
	local real tuple_temp_2
	local real tuple_temp_3
	local real tuple_temp_4
	local real tuple_temp_5
	local real tuple_temp_6
	local real tuple_temp_7
	if MagicFunctions_compiletime then
		set cond_result = Rect(-1024., -1024., 1024., 1024.)
	else
		set cond_result = GetPlayableMapRect()
	endif
	set MapBounds_playableMapRect = cond_result
	set receiver = CreateRegion()
	call region_addRect(receiver, MapBounds_playableMapRect)
	if MagicFunctions_compiletime then
		set cond_result_1 = Rect(-1536., -1536., 1536., 1536.)
	else
		set cond_result_1 = GetWorldBounds()
	endif
	set MapBounds_boundRect = cond_result_1
	set receiver_1 = CreateRegion()
	call region_addRect(receiver_1, MapBounds_boundRect)
	set tuple_temp = rect_getMinX(MapBounds_playableMapRect)
	set tuple_temp_1 = rect_getMinY(MapBounds_playableMapRect)
	set MapBounds_playableMin_x = tuple_temp
	set MapBounds_playableMin_y = tuple_temp_1
	set tuple_temp_2 = rect_getMaxX(MapBounds_playableMapRect)
	set tuple_temp_3 = rect_getMaxY(MapBounds_playableMapRect)
	set MapBounds_playableMax_x = tuple_temp_2
	set MapBounds_playableMax_y = tuple_temp_3
	set tuple_temp_4 = rect_getMinX(MapBounds_boundRect)
	set tuple_temp_5 = rect_getMinY(MapBounds_boundRect)
	set MapBounds_boundMin_x = tuple_temp_4
	set MapBounds_boundMin_y = tuple_temp_5
	set tuple_temp_6 = rect_getMaxX(MapBounds_boundRect)
	set tuple_temp_7 = rect_getMaxY(MapBounds_boundRect)
	set MapBounds_boundMax_x = tuple_temp_6
	set MapBounds_boundMax_y = tuple_temp_7
	call vec2_op_mult(vec2_op_plus(MapBounds_playableMin_x, MapBounds_playableMin_y, MapBounds_playableMax_x, MapBounds_playableMax_y), vec2_op_plus_return_y, .5)
	call vec2_op_mult(vec2_op_plus(MapBounds_boundMin_x, MapBounds_boundMin_y, MapBounds_boundMax_x, MapBounds_boundMax_y), vec2_op_plus_return_y, .5)
endfunction

function init_MapBounds takes nothing returns boolean
	call initMapBounds()
	return true
endfunction

function init_Maths takes nothing returns boolean
	return true
endfunction

function init_Matrices takes nothing returns boolean
	local real tuple_temp = 0.
	local real tuple_temp_1 = 0.
	local real tuple_temp_2 = 0.
	local real tuple_temp_3 = 0.
	local real tuple_temp_4 = 0.
	local real tuple_temp_5 = 0.
	local real tuple_temp_6 = 0.
	local real tuple_temp_7 = 0.
	local real tuple_temp_8 = 0.
	local real tuple_temp_9 = 0.
	local real tuple_temp_10 = 0.
	local real tuple_temp_11 = 0.
	local real tuple_temp_12 = 0.
	local real tuple_temp_13 = 0.
	local real tuple_temp_14 = 0.
	local real tuple_temp_15 = 0.
	set Matrices_ZERO44_m00 = tuple_temp
	set Matrices_ZERO44_m01 = tuple_temp_1
	set Matrices_ZERO44_m02 = tuple_temp_2
	set Matrices_ZERO44_m03 = tuple_temp_3
	set Matrices_ZERO44_m10 = tuple_temp_4
	set Matrices_ZERO44_m11 = tuple_temp_5
	set Matrices_ZERO44_m12 = tuple_temp_6
	set Matrices_ZERO44_m13 = tuple_temp_7
	set Matrices_ZERO44_m20 = tuple_temp_8
	set Matrices_ZERO44_m21 = tuple_temp_9
	set Matrices_ZERO44_m22 = tuple_temp_10
	set Matrices_ZERO44_m23 = tuple_temp_11
	set Matrices_ZERO44_m30 = tuple_temp_12
	set Matrices_ZERO44_m31 = tuple_temp_13
	set Matrices_ZERO44_m32 = tuple_temp_14
	set Matrices_ZERO44_m33 = tuple_temp_15
	return true
endfunction

function init_ObjectIds takes nothing returns boolean
	return true
endfunction

function init_Objects takes nothing returns boolean
	return true
endfunction

function initPlayerArray takes nothing returns nothing
	local integer i = 0
	local integer temp = bj_MAX_PLAYER_SLOTS - 1
	loop
		exitwhen i > temp
		set Player_players[i] = Player(i)
		set i = i + 1
	endloop
endfunction

function init_Player takes nothing returns boolean
	set Player_localPlayer = GetLocalPlayer()
	call initPlayerArray()
	return true
endfunction

function init_Playercolor takes nothing returns boolean
	call ConvertPlayerColor(24)
	call ConvertPlayerColor(25)
	call ConvertPlayerColor(26)
	call ConvertPlayerColor(27)
	return true
endfunction

function init_Printing takes nothing returns boolean
	set Printing_DEBUG_LEVEL = 2
	set Printing_DEBUG_MSG_DURATION = 45.
	return true
endfunction

function init_Quaternion takes nothing returns boolean
	return true
endfunction

function init_Real takes nothing returns boolean
	set Real_REAL_MAX = 340282366920938000000000000000000000000.
	return true
endfunction

function init_Sounds takes nothing returns boolean
	return true
endfunction

function init_Soundsets takes nothing returns boolean
	return true
endfunction

function init_String takes nothing returns boolean
	set String_charset = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	set String_numberset = "0123456789"
	call string_length(String_numberset)
	call string_length(String_charset)
	return true
endfunction

function init_Table takes nothing returns boolean
	set Table_ht = hashtable_compiletime_247
	return true
endfunction

function init_TargetsAllowed takes nothing returns boolean
	return true
endfunction

function init_Textures takes nothing returns boolean
	return true
endfunction

function init_UI takes nothing returns boolean
	return true
endfunction

function init_UnitIds takes nothing returns boolean
	return true
endfunction

function init_Units takes nothing returns boolean
	return true
endfunction

function init_Vectors takes nothing returns boolean
	local real tuple_temp = 0.
	local real tuple_temp_1 = 0.
	set Vectors_ZERO2_x = tuple_temp
	set Vectors_ZERO2_y = tuple_temp_1
	call Location(0., 0.)
	return true
endfunction

function init_WeatherEffects takes nothing returns boolean
	return true
endfunction

function initGlobals takes nothing returns nothing
	set gg_trg_Melee_Initialization = null
	set ForGroupCallback_firstFree = 0
	set ForGroupCallback_maxIndex = 0
	set CallbackSingle_firstFree = 0
	set CallbackSingle_maxIndex = 0
	set ArrayQueue_firstFree = 0
	set ArrayQueue_maxIndex = 0
	set DelayNode_firstFree = 0
	set Table_firstFree = 0
	set Table_maxIndex = 0
	set Comparator_firstFree = 0
	set Comparator_maxIndex = 0
	set LLEntry_firstFree = 0
	set LLEntry_maxIndex = 0
	set IdGenerator_firstFree = 0
	set IdGenerator_maxIndex = 0
	set ref_function_Trig_Melee_Initialization_Actions = function Trig_Melee_Initialization_Actions
	set ref_function_init_Abilities = function init_Abilities
	set ref_function_init_AbilityIds = function init_AbilityIds
	set ref_function_init_Real = function init_Real
	set ref_function_init_Integer = function init_Integer
	set ref_function_init_BitSet = function init_BitSet
	set ref_function_init_String = function init_String
	set ref_function_init_TargetsAllowed = function init_TargetsAllowed
	set ref_function_init_Angle = function init_Angle
	set ref_function_init_Vectors = function init_Vectors
	set ref_function_init_Player = function init_Player
	set ref_function_init_Destructable = function init_Destructable
	set ref_function_init_Maths = function init_Maths
	set ref_function_init_Printing = function init_Printing
	set ref_function_init_MagicFunctions = function init_MagicFunctions
	set ref_function_init_Basics = function init_Basics
	set ref_function_init_GameTimer = function init_GameTimer
	set ref_function_init_ErrorHandling = function init_ErrorHandling
	set ref_function_init_Matrices = function init_Matrices
	set ref_function_init_Quaternion = function init_Quaternion
	set ref_function_init_Table = function init_Table
	set ref_function_init_Playercolor = function init_Playercolor
	set ref_function_bridge_init_Colors = function bridge_init_Colors
	set ref_function_init_Framehandle = function init_Framehandle
	set ref_function_init_Group = function init_Group
	set ref_function_init_Lightning = function init_Lightning
	set ref_function_init_WeatherEffects = function init_WeatherEffects
	set ref_function_bridge_init_TypeCasting = function bridge_init_TypeCasting
	set ref_function_init_HashList = function init_HashList
	set ref_function_bridge_init_EventHelper = function bridge_init_EventHelper
	set ref_function_init_AbilityObjEditing = function init_AbilityObjEditing
	set ref_function_init_AttachmentPoints = function init_AttachmentPoints
	set ref_function_init_Buildings = function init_Buildings
	set ref_function_init_ClosureForGroups = function init_ClosureForGroups
	set ref_function_bridge_init_TimerUtils = function bridge_init_TimerUtils
	set ref_function_init_ClosureTimers = function init_ClosureTimers
	set ref_function_init_Doodads = function init_Doodads
	set ref_function_init_MapBounds = function init_MapBounds
	set ref_function_bridge_init_LinkedList = function bridge_init_LinkedList
	set ref_function_init_ObjectIds = function init_ObjectIds
	set ref_function_init_UnitIds = function init_UnitIds
	set ref_function_init_Icons = function init_Icons
	set ref_function_bridge_init_DummyRecycler = function bridge_init_DummyRecycler
	set ref_function_init_Objects = function init_Objects
	set ref_function_init_Sounds = function init_Sounds
	set ref_function_init_Soundsets = function init_Soundsets
	set ref_function_init_Textures = function init_Textures
	set ref_function_init_UI = function init_UI
	set ref_function_init_Units = function init_Units
	set ref_function_bridge_init_Preloader = function bridge_init_Preloader
	set ref_function_bridge_init_ObjectIdGenerator = function bridge_init_ObjectIdGenerator
	set ref_function_bridge_init_ObjectIDManager = function bridge_init_ObjectIDManager
	set ref_function_bridge_init_LocalObjectIDs = function bridge_init_LocalObjectIDs
	set ref_function_init_Founder = function init_Founder
	set ref_function_bridge_code__Filter_ClosureForGroups = function bridge_code__Filter_ClosureForGroups
	set ref_function_bridge_DelayNode_recycle = function bridge_DelayNode_recycle
	set ref_function_code__startPeriodic_GameTimer = function code__startPeriodic_GameTimer
	set ref_function_bridge_code__start_CallbackSingle_ClosureTimers = function bridge_code__start_CallbackSingle_ClosureTimers
endfunction

function main takes nothing returns nothing
	local trigger initTrig
	call initGlobals()
	call initCompiletimeState()
	call SetCameraBounds(( - 3328.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), ( - 3584.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), ( - 3328.0) + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), ( - 3584.0) + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
	call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
	call NewSoundEnvironment("Default")
	call SetAmbientDaySound("LordaeronSummerDay")
	call SetAmbientNightSound("LordaeronSummerNight")
	call SetMapMusic("Music", true, 0)
	call InitBlizzard()
	call InitGlobals()
	call InitTrig_Melee_Initialization()
	call ConditionalTriggerExecute(gg_trg_Melee_Initialization)
	set initTrig = CreateTrigger()
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Abilities))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Abilities.", "when calling error in Abilities, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AbilityIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AbilityIds.", "when calling error in AbilityIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Real))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Real.", "when calling error in Real, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Integer))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Integer.", "when calling error in Integer, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_BitSet))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package BitSet.", "when calling error in BitSet, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_String))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package String.", "when calling error in String, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_TargetsAllowed))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TargetsAllowed.", "when calling error in TargetsAllowed, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Angle))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Angle.", "when calling error in Angle, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Vectors))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Vectors.", "when calling error in Vectors, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Player))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Player.", "when calling error in Player, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Destructable))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Destructable.", "when calling error in Destructable, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Maths))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Maths.", "when calling error in Maths, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Printing))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Printing.", "when calling error in Printing, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_MagicFunctions))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package MagicFunctions.", "when calling error in MagicFunctions, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Basics))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Basics.", "when calling error in Basics, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_GameTimer))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package GameTimer.", "when calling error in GameTimer, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ErrorHandling))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ErrorHandling.", "when calling error in ErrorHandling, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Matrices))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Matrices.", "when calling error in Matrices, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Quaternion))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Quaternion.", "when calling error in Quaternion, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Table))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Table.", "when calling error in Table, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Playercolor))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Playercolor.", "when calling error in Playercolor, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Colors))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Colors.", "when calling error in Colors, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Framehandle))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Framehandle.", "when calling error in Framehandle, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Group))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Group.", "when calling error in Group, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Lightning))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Lightning.", "when calling error in Lightning, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_WeatherEffects))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package WeatherEffects.", "when calling error in WeatherEffects, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_TypeCasting))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TypeCasting.", "when calling error in TypeCasting, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_HashList))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package HashList.", "when calling error in HashList, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_EventHelper))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package EventHelper.", "when calling error in EventHelper, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AbilityObjEditing))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AbilityObjEditing.", "when calling error in AbilityObjEditing, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_AttachmentPoints))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package AttachmentPoints.", "when calling error in AttachmentPoints, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Buildings))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Buildings.", "when calling error in Buildings, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ClosureForGroups))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ClosureForGroups.", "when calling error in ClosureForGroups, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_TimerUtils))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package TimerUtils.", "when calling error in TimerUtils, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ClosureTimers))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ClosureTimers.", "when calling error in ClosureTimers, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Doodads))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Doodads.", "when calling error in Doodads, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_MapBounds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package MapBounds.", "when calling error in MapBounds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_LinkedList))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package LinkedList.", "when calling error in LinkedList, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_ObjectIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ObjectIds.", "when calling error in ObjectIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_UnitIds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package UnitIds.", "when calling error in UnitIds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Icons))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Icons.", "when calling error in Icons, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_DummyRecycler))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package DummyRecycler.", "when calling error in DummyRecycler, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Objects))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Objects.", "when calling error in Objects, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Sounds))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Sounds.", "when calling error in Sounds, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Soundsets))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Soundsets.", "when calling error in Soundsets, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Textures))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Textures.", "when calling error in Textures, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_UI))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package UI.", "when calling error in UI, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Units))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Units.", "when calling error in Units, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_Preloader))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Preloader.", "when calling error in Preloader, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ObjectIdGenerator))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ObjectIdGenerator.", "when calling error in ObjectIdGenerator, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_ObjectIDManager))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package ObjectIDManager.", "when calling error in ObjectIDManager, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_bridge_init_LocalObjectIDs))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package LocalObjectIDs.", "when calling error in LocalObjectIDs, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call TriggerAddCondition(initTrig, Condition(ref_function_init_Founder))
	if  not TriggerEvaluate(initTrig) then
		call error("Could not initialize package Founder.", "when calling error in Founder, line 1")
	endif
	call TriggerClearConditions(initTrig)
	call DestroyTrigger(initTrig)
	set initTrig = null
endfunction

function InitCustomPlayerSlots takes nothing returns nothing
	call SetPlayerStartLocation(Player(0), 0)
	call SetPlayerColor(Player(0), ConvertPlayerColor(0))
	call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
	call SetPlayerRaceSelectable(Player(0), true)
	call SetPlayerController(Player(0), MAP_CONTROL_USER)
endfunction

function config takes nothing returns nothing
	call SetMapName("Just another Warcraft III map")
	call SetMapDescription("Nondescript")
	call SetPlayers(1)
	call SetTeams(1)
	call SetGamePlacement(MAP_PLACEMENT_USE_MAP_SETTINGS)
	call DefineStartLocation(0,  - 64.0, 64.0)
	call InitCustomPlayerSlots()
	call SetPlayerSlotAvailable(Player(0), MAP_CONTROL_USER)
	call InitGenericPlayerSlots()
endfunction

